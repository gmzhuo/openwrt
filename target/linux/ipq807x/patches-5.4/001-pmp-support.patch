Index: linux-5.4.52/drivers/iio/adc/qcom-spmi-vadc.c
===================================================================
--- linux-5.4.52.orig/drivers/iio/adc/qcom-spmi-vadc.c
+++ linux-5.4.52/drivers/iio/adc/qcom-spmi-vadc.c
@@ -1,6 +1,14 @@
-// SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  */
 
 #include <linux/bitops.h>
@@ -14,63 +22,176 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
+#include <linux/of_device.h>
 #include <linux/regmap.h>
 #include <linux/slab.h>
 #include <linux/log2.h>
+#include <linux/thermal.h>
 
 #include <dt-bindings/iio/qcom,spmi-vadc.h>
 
-#include "qcom-vadc-common.h"
-
-/* VADC register and bit definitions */
-#define VADC_REVISION2				0x1
+/* VADC bit definitions */
 #define VADC_REVISION2_SUPPORTED_VADC		1
-
-#define VADC_PERPH_TYPE				0x4
 #define VADC_PERPH_TYPE_ADC			8
-
-#define VADC_PERPH_SUBTYPE			0x5
 #define VADC_PERPH_SUBTYPE_VADC			1
-
-#define VADC_STATUS1				0x8
 #define VADC_STATUS1_OP_MODE			4
 #define VADC_STATUS1_REQ_STS			BIT(1)
 #define VADC_STATUS1_EOC			BIT(0)
 #define VADC_STATUS1_REQ_STS_EOC_MASK		0x3
-
-#define VADC_MODE_CTL				0x40
 #define VADC_OP_MODE_SHIFT			3
 #define VADC_OP_MODE_NORMAL			0
 #define VADC_AMUX_TRIM_EN			BIT(1)
 #define VADC_ADC_TRIM_EN			BIT(0)
-
-#define VADC_EN_CTL1				0x46
 #define VADC_EN_CTL1_SET			BIT(7)
+#define VADC_ADC_DIG_DEC_RATIO_SEL_SHIFT	2
+#define VADC_CONV_REQ_SET			BIT(7)
+#define VADC_FAST_AVG_EN_SET			BIT(7)
+#define VADC_FOLLOW_WARM_RB			BIT(2)
+#define VADC_CONV_TIME_MIN_US			2000
+#define VADC_CONV_TIME_MAX_US			2100
 
-#define VADC_ADC_CH_SEL_CTL			0x48
+#define VADC_ABSOLUTE_RANGE_UV			625000
+#define VADC_RATIOMETRIC_RANGE_UV		1800000
 
-#define VADC_ADC_DIG_PARAM			0x50
-#define VADC_ADC_DIG_DEC_RATIO_SEL_SHIFT	2
+#define VADC_DEF_PRESCALING			0 /* 1:1 */
+#define VADC_DEF_DECIMATION			0 /* 512 */
+#define VADC_DEF_HW_SETTLE_TIME			0 /* 0 us */
+#define VADC_DEF_AVG_SAMPLES			0 /* 1 sample */
+#define VADC_DEF_CALIB_TYPE			VADC_CALIB_ABSOLUTE
+
+#define VADC_DECIMATION_MIN			512
+#define VADC_DECIMATION_MAX			4096
+
+#define VADC_HW_SETTLE_DELAY_MAX		10000
+#define VADC_AVG_SAMPLES_MAX			512
+
+#define KELVINMIL_CELSIUSMIL			273150
+
+#define PMP8074_DIE_TEMP_SLOPE_NUM		10
+#define PMP8074_DIE_TEMP_SLOPE_DEN		171
+#define PMP8074_DIE_TEMP_OFFSET			286
+
+#define PMP8074_PA_THERM_SLOPE			2397
+#define PMP8074_PA_THERM_BASE			506
+#define PMP8074_PA_THERM_FACTOR			100
+
+
+enum vadc_reg {
+	VADC_REVISION2,
+	VADC_PERPH_TYPE,
+	VADC_PERPH_SUBTYPE,
+	VADC_STATUS1,
+	VADC_MODE_CTL,
+	VADC_EN_CTL1,
+	VADC_ADC_DIG_PARAM,
+	VADC_FAST_AVG_CTL,
+	VADC_FAST_AVG_EN,
+	VADC_ADC_CH_SEL_CTL,
+	VADC_HW_SETTLE_DELAY,
+	VADC_CONV_REQ,
+	VADC_DATA,
+	VADC_ACCESS,
+	VADC_ACCESS_DATA,
+	VADC_PERH_RESET_CTL3,
+	VADC_REG_MAX
+};
 
-#define VADC_HW_SETTLE_DELAY			0x51
+static u32 reg_offset_default[] = {
+	[VADC_REVISION2] = 0x1,
+	[VADC_PERPH_TYPE] = 0x4,
+	[VADC_PERPH_SUBTYPE] = 0x5,
+	[VADC_STATUS1] = 0x8,
+	[VADC_MODE_CTL] = 0x40,
+	[VADC_EN_CTL1] = 0x46,
+	[VADC_ADC_DIG_PARAM] = 0x50,
+	[VADC_FAST_AVG_CTL] = 0x5a,
+	[VADC_FAST_AVG_EN] = 0x5b,
+	[VADC_ADC_CH_SEL_CTL] = 0x48,
+	[VADC_HW_SETTLE_DELAY] = 0x51,
+	[VADC_CONV_REQ] = 0x52,
+	[VADC_DATA] = 0x60,
+	[VADC_ACCESS] = 0xd0,
+	[VADC_ACCESS_DATA] = 0xa5,
+	[VADC_PERH_RESET_CTL3] = 0xda
+};
 
-#define VADC_CONV_REQ				0x52
-#define VADC_CONV_REQ_SET			BIT(7)
+static u32 reg_offset_pmp8074[] = {
+	[VADC_REVISION2] = 0x1,
+	[VADC_PERPH_TYPE] = 0x4,
+	[VADC_PERPH_SUBTYPE] = 0x5,
+	[VADC_STATUS1] = 0x8,
+	[VADC_EN_CTL1] = 0x46,
+	[VADC_ADC_DIG_PARAM] = 0x42,
+	[VADC_FAST_AVG_CTL] = 0x43,
+	[VADC_FAST_AVG_EN] = 0x43,
+	[VADC_ADC_CH_SEL_CTL] = 0x44,
+	[VADC_HW_SETTLE_DELAY] = 0x45,
+	[VADC_CONV_REQ] = 0x47,
+	[VADC_DATA] = 0x50,
+	[VADC_ACCESS] = 0xd0,
+	[VADC_ACCESS_DATA] = 0xa5,
+	[VADC_PERH_RESET_CTL3] = 0xda
+};
 
-#define VADC_FAST_AVG_CTL			0x5a
-#define VADC_FAST_AVG_EN			0x5b
-#define VADC_FAST_AVG_EN_SET			BIT(7)
+struct vadc_priv;
 
-#define VADC_ACCESS				0xd0
-#define VADC_ACCESS_DATA			0xa5
+struct device_data {
+	struct vadc_channels *vadc_chans;
+	u32 *reg;
+	bool mode_ctl;
+	bool dynamic_calib;
+	bool force_decimation;
+	u16 ch_min;
+	u16 ch_max;
+	u32 decimation_mask;
+	u32 adc_min;
+	u32 adc_max;
+	u32 uV_max;
+	u32 (*adc_to_uV)(struct vadc_priv *, u16);
+	int (*adc_to_degc)(struct vadc_priv *, u16);
+	struct thermal_zone_device_ops *thermal_ops;
+};
 
-#define VADC_PERH_RESET_CTL3			0xda
-#define VADC_FOLLOW_WARM_RB			BIT(2)
+struct vadc_thermal_data {
+	int thermal_chan;
+	struct thermal_zone_device *tz_dev;
+	struct vadc_priv *vadc_dev;
+};
+
+/*
+ * VADC_CALIB_ABSOLUTE: uses the 625mV and 1.25V as reference channels.
+ * VADC_CALIB_RATIOMETRIC: uses the reference voltage (1.8V) and GND for
+ * calibration.
+ */
+enum vadc_calibration {
+	VADC_CALIB_ABSOLUTE = 0,
+	VADC_CALIB_RATIOMETRIC
+};
 
-#define VADC_DATA				0x60	/* 16 bits */
+/**
+ * struct vadc_linear_graph - Represent ADC characteristics.
+ * @dy: numerator slope to calculate the gain.
+ * @dx: denominator slope to calculate the gain.
+ * @gnd: A/D word of the ground reference used for the channel.
+ *
+ * Each ADC device has different offset and gain parameters which are
+ * computed to calibrate the device.
+ */
+struct vadc_linear_graph {
+	s32 dy;
+	s32 dx;
+	s32 gnd;
+};
 
-#define VADC_CHAN_MIN			VADC_USBIN
-#define VADC_CHAN_MAX			VADC_LR_MUX3_BUF_PU1_PU2_XO_THERM
+/**
+ * struct vadc_prescale_ratio - Represent scaling ratio for ADC input.
+ * @num: the inverse numerator of the gain applied to the input channel.
+ * @den: the inverse denominator of the gain applied to the input channel.
+ */
+struct vadc_prescale_ratio {
+	u32 num;
+	u32 den;
+};
 
 /**
  * struct vadc_channel_prop - VADC channel property.
@@ -82,8 +203,6 @@
  *	start of conversion.
  * @avg_samples: ability to provide single result from the ADC
  *	that is an average of multiple measurements.
- * @scale_fn_type: Represents the scaling function to convert voltage
- *	physical units desired by the client for the channel.
  */
 struct vadc_channel_prop {
 	unsigned int channel;
@@ -92,7 +211,6 @@ struct vadc_channel_prop {
 	unsigned int prescale;
 	unsigned int hw_settle_time;
 	unsigned int avg_samples;
-	enum vadc_scale_fn_type scale_fn_type;
 };
 
 /**
@@ -121,6 +239,8 @@ struct vadc_priv {
 	struct completion	 complete;
 	struct vadc_linear_graph graph[2];
 	struct mutex		 lock;
+	struct device_data	 *dev_data;
+	struct vadc_thermal_data *vadc_therm_chan;
 };
 
 static const struct vadc_prescale_ratio vadc_prescale_ratios[] = {
@@ -134,14 +254,16 @@ static const struct vadc_prescale_ratio
 	{.num =  1, .den = 10}
 };
 
-static int vadc_read(struct vadc_priv *vadc, u16 offset, u8 *data)
+static int vadc_read(struct vadc_priv *vadc, enum vadc_reg reg, u8 *data)
 {
-	return regmap_bulk_read(vadc->regmap, vadc->base + offset, data, 1);
+	u32 reg_offset = vadc->dev_data->reg[reg];
+	return regmap_bulk_read(vadc->regmap, vadc->base + reg_offset, data, 1);
 }
 
-static int vadc_write(struct vadc_priv *vadc, u16 offset, u8 data)
+static int vadc_write(struct vadc_priv *vadc, enum vadc_reg reg, u8 data)
 {
-	return regmap_write(vadc->regmap, vadc->base + offset, data);
+	u32 reg_offset = vadc->dev_data->reg[reg];
+	return regmap_write(vadc->regmap, vadc->base + reg_offset, data);
 }
 
 static int vadc_reset(struct vadc_priv *vadc)
@@ -173,12 +295,14 @@ static int vadc_set_state(struct vadc_pr
 
 static void vadc_show_status(struct vadc_priv *vadc)
 {
-	u8 mode, sta1, chan, dig, en, req;
+	u8 mode = 0, sta1, chan, dig, en, req;
 	int ret;
 
-	ret = vadc_read(vadc, VADC_MODE_CTL, &mode);
-	if (ret)
-		return;
+	if (vadc->dev_data->mode_ctl) {
+		ret = vadc_read(vadc, VADC_MODE_CTL, &mode);
+		if (ret)
+			return;
+	}
 
 	ret = vadc_read(vadc, VADC_ADC_DIG_PARAM, &dig);
 	if (ret)
@@ -208,15 +332,17 @@ static void vadc_show_status(struct vadc
 static int vadc_configure(struct vadc_priv *vadc,
 			  struct vadc_channel_prop *prop)
 {
-	u8 decimation, mode_ctrl;
+	u8 decimation, mode_ctrl, val;
 	int ret;
 
-	/* Mode selection */
-	mode_ctrl = (VADC_OP_MODE_NORMAL << VADC_OP_MODE_SHIFT) |
-		     VADC_ADC_TRIM_EN | VADC_AMUX_TRIM_EN;
-	ret = vadc_write(vadc, VADC_MODE_CTL, mode_ctrl);
-	if (ret)
-		return ret;
+	if (vadc->dev_data->mode_ctl) {
+		/* Mode selection */
+		mode_ctrl = (VADC_OP_MODE_NORMAL << VADC_OP_MODE_SHIFT) |
+			     VADC_ADC_TRIM_EN | VADC_AMUX_TRIM_EN;
+		ret = vadc_write(vadc, VADC_MODE_CTL, mode_ctrl);
+		if (ret)
+			return ret;
+	}
 
 	/* Channel selection */
 	ret = vadc_write(vadc, VADC_ADC_CH_SEL_CTL, prop->channel);
@@ -225,6 +351,13 @@ static int vadc_configure(struct vadc_pr
 
 	/* Digital parameter setup */
 	decimation = prop->decimation << VADC_ADC_DIG_DEC_RATIO_SEL_SHIFT;
+	if (!vadc->dev_data->force_decimation) {
+		ret = vadc_read(vadc, VADC_ADC_DIG_PARAM, &val);
+		if (ret)
+			return ret;
+		val &= (~vadc->dev_data->decimation_mask);
+		decimation |= val;
+	}
 	ret = vadc_write(vadc, VADC_ADC_DIG_PARAM, decimation);
 	if (ret)
 		return ret;
@@ -275,15 +408,56 @@ static int vadc_read_result(struct vadc_
 {
 	int ret;
 
-	ret = regmap_bulk_read(vadc->regmap, vadc->base + VADC_DATA, data, 2);
+	ret = regmap_bulk_read(vadc->regmap, vadc->base
+			+ vadc->dev_data->reg[VADC_DATA], data, 2);
 	if (ret)
 		return ret;
 
-	*data = clamp_t(u16, *data, VADC_MIN_ADC_CODE, VADC_MAX_ADC_CODE);
+	*data = clamp_t(u16, *data,
+			vadc->dev_data->adc_min, vadc->dev_data->adc_max);
 
 	return 0;
 }
 
+/*
+ * Convert ADC to voltage using the formula
+ * voltage = (adc_code * max uV)/Max ADC
+ *
+ */
+static u32 pmp8074_adc_to_uV(struct vadc_priv *vadc, u16 adc_code)
+{
+	u32 voltage, quot, reminder;
+
+	pr_info("Raw ADC: %d\n", adc_code);
+
+	quot = (adc_code * (vadc->dev_data->uV_max/1000))
+				/vadc->dev_data->adc_max;
+	reminder = (adc_code * (vadc->dev_data->uV_max/1000))
+				%vadc->dev_data->adc_max;
+
+	/* Convert into mV to uV without losing granuality */
+	reminder = (reminder * 1000)/vadc->dev_data->adc_max;
+	voltage = (quot * 1000) + reminder;
+
+	return voltage;
+}
+
+/*
+ * Convert ADC to temperature in deg.C
+ * PMIC_CaseTemp(deg.C) = (10/171) * (RawADCval) - 286
+ *
+ */
+static int pmp8074_adc_to_degc(struct vadc_priv *vadc, u16 adc_code)
+{
+	int degc;
+
+	pr_info("Raw ADC: %d\n", adc_code);
+	degc = ((PMP8074_DIE_TEMP_SLOPE_NUM * adc_code)
+		/PMP8074_DIE_TEMP_SLOPE_DEN) - PMP8074_DIE_TEMP_OFFSET;
+
+	return degc;
+}
+
 static struct vadc_channel_prop *vadc_get_channel(struct vadc_priv *vadc,
 						  unsigned int num)
 {
@@ -355,10 +529,14 @@ static int vadc_measure_ref_points(struc
 	u16 read_1, read_2;
 	int ret;
 
-	vadc->graph[VADC_CALIB_RATIOMETRIC].dx = VADC_RATIOMETRIC_RANGE;
+	vadc->graph[VADC_CALIB_RATIOMETRIC].dx = VADC_RATIOMETRIC_RANGE_UV;
 	vadc->graph[VADC_CALIB_ABSOLUTE].dx = VADC_ABSOLUTE_RANGE_UV;
 
 	prop = vadc_get_channel(vadc, VADC_REF_1250MV);
+	if (!prop) {
+		ret = -EINVAL;
+		goto err;
+	}
 	ret = vadc_do_conversion(vadc, prop, &read_1);
 	if (ret)
 		goto err;
@@ -368,6 +546,10 @@ static int vadc_measure_ref_points(struc
 	if (!prop)
 		prop = vadc_get_channel(vadc, VADC_REF_625MV);
 
+	if (!prop) {
+		ret = -EINVAL;
+		goto err;
+	}
 	ret = vadc_do_conversion(vadc, prop, &read_2);
 	if (ret)
 		goto err;
@@ -382,11 +564,19 @@ static int vadc_measure_ref_points(struc
 
 	/* Ratiometric calibration */
 	prop = vadc_get_channel(vadc, VADC_VDD_VADC);
+	if (!prop) {
+		ret = -EINVAL;
+		goto err;
+	}
 	ret = vadc_do_conversion(vadc, prop, &read_1);
 	if (ret)
 		goto err;
 
 	prop = vadc_get_channel(vadc, VADC_GND_REF);
+	if (!prop) {
+		ret = -EINVAL;
+		goto err;
+	}
 	ret = vadc_do_conversion(vadc, prop, &read_2);
 	if (ret)
 		goto err;
@@ -405,6 +595,38 @@ err:
 	return ret;
 }
 
+static s32 vadc_calibrate(struct vadc_priv *vadc,
+			  const struct vadc_channel_prop *prop, u16 adc_code)
+{
+	const struct vadc_prescale_ratio *prescale;
+	s64 voltage;
+
+	voltage = adc_code - vadc->graph[prop->calibration].gnd;
+	voltage *= vadc->graph[prop->calibration].dx;
+	voltage = div64_s64(voltage, vadc->graph[prop->calibration].dy);
+
+	if (prop->calibration == VADC_CALIB_ABSOLUTE)
+		voltage += vadc->graph[prop->calibration].dx;
+
+	if (voltage < 0)
+		voltage = 0;
+
+	prescale = &vadc_prescale_ratios[prop->prescale];
+
+	voltage = voltage * prescale->den;
+
+	return div64_s64(voltage, prescale->num);
+}
+
+static int vadc_decimation_from_dt(u32 value)
+{
+	if (!is_power_of_2(value) || value < VADC_DECIMATION_MIN ||
+	    value > VADC_DECIMATION_MAX)
+		return -EINVAL;
+
+	return __ffs64(value / VADC_DECIMATION_MIN);
+}
+
 static int vadc_prescaling_from_dt(u32 num, u32 den)
 {
 	unsigned int pre;
@@ -457,13 +679,20 @@ static int vadc_read_raw(struct iio_dev
 		if (ret)
 			break;
 
-		ret = qcom_vadc_scale(prop->scale_fn_type,
-				&vadc->graph[prop->calibration],
-				&vadc_prescale_ratios[prop->prescale],
-				(prop->calibration == VADC_CALIB_ABSOLUTE),
-				adc_code, val);
-		if (ret)
-			break;
+		if (!vadc->dev_data->dynamic_calib) {
+			if (vadc->dev_data->adc_to_degc)
+				*val = vadc->dev_data->adc_to_degc(vadc,
+								adc_code);
+			else
+				return -EINVAL;
+		}
+		else {
+			*val = vadc_calibrate(vadc, prop, adc_code);
+
+			/* 2mV/K, return milli Celsius */
+			*val /= 2;
+			*val -= KELVINMIL_CELSIUSMIL;
+		}
 
 		return IIO_VAL_INT;
 	case IIO_CHAN_INFO_RAW:
@@ -472,8 +701,20 @@ static int vadc_read_raw(struct iio_dev
 		if (ret)
 			break;
 
-		*val = (int)adc_code;
+		if (!vadc->dev_data->dynamic_calib) {
+			if (vadc->dev_data->adc_to_uV)
+				*val = vadc->dev_data->adc_to_uV(vadc,
+								adc_code);
+			else
+				return -EINVAL;
+		} else
+			*val = vadc_calibrate(vadc, prop, adc_code);
+
 		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		*val = 0;
+		*val2 = 1000;
+		return IIO_VAL_INT_PLUS_MICRO;
 	default:
 		ret = -EINVAL;
 		break;
@@ -498,6 +739,7 @@ static int vadc_of_xlate(struct iio_dev
 static const struct iio_info vadc_info = {
 	.read_raw = vadc_read_raw,
 	.of_xlate = vadc_of_xlate,
+	//.driver_module = THIS_MODULE,
 };
 
 struct vadc_channels {
@@ -505,39 +747,22 @@ struct vadc_channels {
 	unsigned int prescale_index;
 	enum iio_chan_type type;
 	long info_mask;
-	enum vadc_scale_fn_type scale_fn_type;
 };
 
-#define VADC_CHAN(_dname, _type, _mask, _pre, _scale)			\
-	[VADC_##_dname] = {						\
-		.datasheet_name = __stringify(_dname),			\
-		.prescale_index = _pre,					\
-		.type = _type,						\
-		.info_mask = _mask,					\
-		.scale_fn_type = _scale					\
-	},								\
-
-#define VADC_NO_CHAN(_dname, _type, _mask, _pre)			\
+#define VADC_CHAN(_dname, _type, _mask, _pre)				\
 	[VADC_##_dname] = {						\
 		.datasheet_name = __stringify(_dname),			\
 		.prescale_index = _pre,					\
 		.type = _type,						\
 		.info_mask = _mask					\
-	},
+	},								\
 
-#define VADC_CHAN_TEMP(_dname, _pre, _scale)				\
-	VADC_CHAN(_dname, IIO_TEMP,					\
-		BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_PROCESSED),	\
-		_pre, _scale)						\
+#define VADC_CHAN_TEMP(_dname, _pre)					\
+	VADC_CHAN(_dname, IIO_TEMP, BIT(IIO_CHAN_INFO_PROCESSED), _pre)	\
 
-#define VADC_CHAN_VOLT(_dname, _pre, _scale)				\
+#define VADC_CHAN_VOLT(_dname, _pre)					\
 	VADC_CHAN(_dname, IIO_VOLTAGE,					\
-		  BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_PROCESSED),\
-		  _pre, _scale)						\
-
-#define VADC_CHAN_NO_SCALE(_dname, _pre)				\
-	VADC_NO_CHAN(_dname, IIO_VOLTAGE,				\
-		  BIT(IIO_CHAN_INFO_RAW),				\
+		  BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),	\
 		  _pre)							\
 
 /*
@@ -545,112 +770,133 @@ struct vadc_channels {
  * Every index in the array is equal to the channel number per datasheet. The
  * gaps in the array should be treated as reserved channels.
  */
-static const struct vadc_channels vadc_chans[] = {
-	VADC_CHAN_VOLT(USBIN, 4, SCALE_DEFAULT)
-	VADC_CHAN_VOLT(DCIN, 4, SCALE_DEFAULT)
-	VADC_CHAN_NO_SCALE(VCHG_SNS, 3)
-	VADC_CHAN_NO_SCALE(SPARE1_03, 1)
-	VADC_CHAN_NO_SCALE(USB_ID_MV, 1)
-	VADC_CHAN_VOLT(VCOIN, 1, SCALE_DEFAULT)
-	VADC_CHAN_NO_SCALE(VBAT_SNS, 1)
-	VADC_CHAN_VOLT(VSYS, 1, SCALE_DEFAULT)
-	VADC_CHAN_TEMP(DIE_TEMP, 0, SCALE_PMIC_THERM)
-	VADC_CHAN_VOLT(REF_625MV, 0, SCALE_DEFAULT)
-	VADC_CHAN_VOLT(REF_1250MV, 0, SCALE_DEFAULT)
-	VADC_CHAN_NO_SCALE(CHG_TEMP, 0)
-	VADC_CHAN_NO_SCALE(SPARE1, 0)
-	VADC_CHAN_TEMP(SPARE2, 0, SCALE_PMI_CHG_TEMP)
-	VADC_CHAN_VOLT(GND_REF, 0, SCALE_DEFAULT)
-	VADC_CHAN_VOLT(VDD_VADC, 0, SCALE_DEFAULT)
-
-	VADC_CHAN_NO_SCALE(P_MUX1_1_1, 0)
-	VADC_CHAN_NO_SCALE(P_MUX2_1_1, 0)
-	VADC_CHAN_NO_SCALE(P_MUX3_1_1, 0)
-	VADC_CHAN_NO_SCALE(P_MUX4_1_1, 0)
-	VADC_CHAN_NO_SCALE(P_MUX5_1_1, 0)
-	VADC_CHAN_NO_SCALE(P_MUX6_1_1, 0)
-	VADC_CHAN_NO_SCALE(P_MUX7_1_1, 0)
-	VADC_CHAN_NO_SCALE(P_MUX8_1_1, 0)
-	VADC_CHAN_NO_SCALE(P_MUX9_1_1, 0)
-	VADC_CHAN_NO_SCALE(P_MUX10_1_1, 0)
-	VADC_CHAN_NO_SCALE(P_MUX11_1_1, 0)
-	VADC_CHAN_NO_SCALE(P_MUX12_1_1, 0)
-	VADC_CHAN_NO_SCALE(P_MUX13_1_1, 0)
-	VADC_CHAN_NO_SCALE(P_MUX14_1_1, 0)
-	VADC_CHAN_NO_SCALE(P_MUX15_1_1, 0)
-	VADC_CHAN_NO_SCALE(P_MUX16_1_1, 0)
-
-	VADC_CHAN_NO_SCALE(P_MUX1_1_3, 1)
-	VADC_CHAN_NO_SCALE(P_MUX2_1_3, 1)
-	VADC_CHAN_NO_SCALE(P_MUX3_1_3, 1)
-	VADC_CHAN_NO_SCALE(P_MUX4_1_3, 1)
-	VADC_CHAN_NO_SCALE(P_MUX5_1_3, 1)
-	VADC_CHAN_NO_SCALE(P_MUX6_1_3, 1)
-	VADC_CHAN_NO_SCALE(P_MUX7_1_3, 1)
-	VADC_CHAN_NO_SCALE(P_MUX8_1_3, 1)
-	VADC_CHAN_NO_SCALE(P_MUX9_1_3, 1)
-	VADC_CHAN_NO_SCALE(P_MUX10_1_3, 1)
-	VADC_CHAN_NO_SCALE(P_MUX11_1_3, 1)
-	VADC_CHAN_NO_SCALE(P_MUX12_1_3, 1)
-	VADC_CHAN_NO_SCALE(P_MUX13_1_3, 1)
-	VADC_CHAN_NO_SCALE(P_MUX14_1_3, 1)
-	VADC_CHAN_NO_SCALE(P_MUX15_1_3, 1)
-	VADC_CHAN_NO_SCALE(P_MUX16_1_3, 1)
-
-	VADC_CHAN_NO_SCALE(LR_MUX1_BAT_THERM, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX2_BAT_ID, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX3_XO_THERM, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX4_AMUX_THM1, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX5_AMUX_THM2, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX6_AMUX_THM3, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX7_HW_ID, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX8_AMUX_THM4, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX9_AMUX_THM5, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX10_USB_ID, 0)
-	VADC_CHAN_NO_SCALE(AMUX_PU1, 0)
-	VADC_CHAN_NO_SCALE(AMUX_PU2, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX3_BUF_XO_THERM, 0)
-
-	VADC_CHAN_NO_SCALE(LR_MUX1_PU1_BAT_THERM, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX2_PU1_BAT_ID, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX3_PU1_XO_THERM, 0)
-	VADC_CHAN_TEMP(LR_MUX4_PU1_AMUX_THM1, 0, SCALE_THERM_100K_PULLUP)
-	VADC_CHAN_TEMP(LR_MUX5_PU1_AMUX_THM2, 0, SCALE_THERM_100K_PULLUP)
-	VADC_CHAN_TEMP(LR_MUX6_PU1_AMUX_THM3, 0, SCALE_THERM_100K_PULLUP)
-	VADC_CHAN_NO_SCALE(LR_MUX7_PU1_AMUX_HW_ID, 0)
-	VADC_CHAN_TEMP(LR_MUX8_PU1_AMUX_THM4, 0, SCALE_THERM_100K_PULLUP)
-	VADC_CHAN_TEMP(LR_MUX9_PU1_AMUX_THM5, 0, SCALE_THERM_100K_PULLUP)
-	VADC_CHAN_NO_SCALE(LR_MUX10_PU1_AMUX_USB_ID, 0)
-	VADC_CHAN_TEMP(LR_MUX3_BUF_PU1_XO_THERM, 0, SCALE_XOTHERM)
-
-	VADC_CHAN_NO_SCALE(LR_MUX1_PU2_BAT_THERM, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX2_PU2_BAT_ID, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX3_PU2_XO_THERM, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX4_PU2_AMUX_THM1, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX5_PU2_AMUX_THM2, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX6_PU2_AMUX_THM3, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX7_PU2_AMUX_HW_ID, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX8_PU2_AMUX_THM4, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX9_PU2_AMUX_THM5, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX10_PU2_AMUX_USB_ID, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX3_BUF_PU2_XO_THERM, 0)
-
-	VADC_CHAN_NO_SCALE(LR_MUX1_PU1_PU2_BAT_THERM, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX2_PU1_PU2_BAT_ID, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX3_PU1_PU2_XO_THERM, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX4_PU1_PU2_AMUX_THM1, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX5_PU1_PU2_AMUX_THM2, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX6_PU1_PU2_AMUX_THM3, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX7_PU1_PU2_AMUX_HW_ID, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX8_PU1_PU2_AMUX_THM4, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX9_PU1_PU2_AMUX_THM5, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX10_PU1_PU2_AMUX_USB_ID, 0)
-	VADC_CHAN_NO_SCALE(LR_MUX3_BUF_PU1_PU2_XO_THERM, 0)
+static struct vadc_channels default_vadc_chans[] = {
+	VADC_CHAN_VOLT(USBIN, 4)
+	VADC_CHAN_VOLT(DCIN, 4)
+	VADC_CHAN_VOLT(VCHG_SNS, 3)
+	VADC_CHAN_VOLT(SPARE1_03, 1)
+	VADC_CHAN_VOLT(USB_ID_MV, 1)
+	VADC_CHAN_VOLT(VCOIN, 1)
+	VADC_CHAN_VOLT(VBAT_SNS, 1)
+	VADC_CHAN_VOLT(VSYS, 1)
+	VADC_CHAN_TEMP(DIE_TEMP, 0)
+	VADC_CHAN_VOLT(REF_625MV, 0)
+	VADC_CHAN_VOLT(REF_1250MV, 0)
+	VADC_CHAN_VOLT(CHG_TEMP, 0)
+	VADC_CHAN_VOLT(SPARE1, 0)
+	VADC_CHAN_VOLT(SPARE2, 0)
+	VADC_CHAN_VOLT(GND_REF, 0)
+	VADC_CHAN_VOLT(VDD_VADC, 0)
+
+	VADC_CHAN_VOLT(P_MUX1_1_1, 0)
+	VADC_CHAN_VOLT(P_MUX2_1_1, 0)
+	VADC_CHAN_VOLT(P_MUX3_1_1, 0)
+	VADC_CHAN_VOLT(P_MUX4_1_1, 0)
+	VADC_CHAN_VOLT(P_MUX5_1_1, 0)
+	VADC_CHAN_VOLT(P_MUX6_1_1, 0)
+	VADC_CHAN_VOLT(P_MUX7_1_1, 0)
+	VADC_CHAN_VOLT(P_MUX8_1_1, 0)
+	VADC_CHAN_VOLT(P_MUX9_1_1, 0)
+	VADC_CHAN_VOLT(P_MUX10_1_1, 0)
+	VADC_CHAN_VOLT(P_MUX11_1_1, 0)
+	VADC_CHAN_VOLT(P_MUX12_1_1, 0)
+	VADC_CHAN_VOLT(P_MUX13_1_1, 0)
+	VADC_CHAN_VOLT(P_MUX14_1_1, 0)
+	VADC_CHAN_VOLT(P_MUX15_1_1, 0)
+	VADC_CHAN_VOLT(P_MUX16_1_1, 0)
+
+	VADC_CHAN_VOLT(P_MUX1_1_3, 1)
+	VADC_CHAN_VOLT(P_MUX2_1_3, 1)
+	VADC_CHAN_VOLT(P_MUX3_1_3, 1)
+	VADC_CHAN_VOLT(P_MUX4_1_3, 1)
+	VADC_CHAN_VOLT(P_MUX5_1_3, 1)
+	VADC_CHAN_VOLT(P_MUX6_1_3, 1)
+	VADC_CHAN_VOLT(P_MUX7_1_3, 1)
+	VADC_CHAN_VOLT(P_MUX8_1_3, 1)
+	VADC_CHAN_VOLT(P_MUX9_1_3, 1)
+	VADC_CHAN_VOLT(P_MUX10_1_3, 1)
+	VADC_CHAN_VOLT(P_MUX11_1_3, 1)
+	VADC_CHAN_VOLT(P_MUX12_1_3, 1)
+	VADC_CHAN_VOLT(P_MUX13_1_3, 1)
+	VADC_CHAN_VOLT(P_MUX14_1_3, 1)
+	VADC_CHAN_VOLT(P_MUX15_1_3, 1)
+	VADC_CHAN_VOLT(P_MUX16_1_3, 1)
+
+	VADC_CHAN_VOLT(LR_MUX1_BAT_THERM, 0)
+	VADC_CHAN_VOLT(LR_MUX2_BAT_ID, 0)
+	VADC_CHAN_VOLT(LR_MUX3_XO_THERM, 0)
+	VADC_CHAN_VOLT(LR_MUX4_AMUX_THM1, 0)
+	VADC_CHAN_VOLT(LR_MUX5_AMUX_THM2, 0)
+	VADC_CHAN_VOLT(LR_MUX6_AMUX_THM3, 0)
+	VADC_CHAN_VOLT(LR_MUX7_HW_ID, 0)
+	VADC_CHAN_VOLT(LR_MUX8_AMUX_THM4, 0)
+	VADC_CHAN_VOLT(LR_MUX9_AMUX_THM5, 0)
+	VADC_CHAN_VOLT(LR_MUX10_USB_ID, 0)
+	VADC_CHAN_VOLT(AMUX_PU1, 0)
+	VADC_CHAN_VOLT(AMUX_PU2, 0)
+	VADC_CHAN_VOLT(LR_MUX3_BUF_XO_THERM, 0)
+
+	VADC_CHAN_VOLT(LR_MUX1_PU1_BAT_THERM, 0)
+	VADC_CHAN_VOLT(LR_MUX2_PU1_BAT_ID, 0)
+	VADC_CHAN_VOLT(LR_MUX3_PU1_XO_THERM, 0)
+	VADC_CHAN_VOLT(LR_MUX4_PU1_AMUX_THM1, 0)
+	VADC_CHAN_VOLT(LR_MUX5_PU1_AMUX_THM2, 0)
+	VADC_CHAN_VOLT(LR_MUX6_PU1_AMUX_THM3, 0)
+	VADC_CHAN_VOLT(LR_MUX7_PU1_AMUX_HW_ID, 0)
+	VADC_CHAN_VOLT(LR_MUX8_PU1_AMUX_THM4, 0)
+	VADC_CHAN_VOLT(LR_MUX9_PU1_AMUX_THM5, 0)
+	VADC_CHAN_VOLT(LR_MUX10_PU1_AMUX_USB_ID, 0)
+	VADC_CHAN_VOLT(LR_MUX3_BUF_PU1_XO_THERM, 0)
+
+	VADC_CHAN_VOLT(LR_MUX1_PU2_BAT_THERM, 0)
+	VADC_CHAN_VOLT(LR_MUX2_PU2_BAT_ID, 0)
+	VADC_CHAN_VOLT(LR_MUX3_PU2_XO_THERM, 0)
+	VADC_CHAN_VOLT(LR_MUX4_PU2_AMUX_THM1, 0)
+	VADC_CHAN_VOLT(LR_MUX5_PU2_AMUX_THM2, 0)
+	VADC_CHAN_VOLT(LR_MUX6_PU2_AMUX_THM3, 0)
+	VADC_CHAN_VOLT(LR_MUX7_PU2_AMUX_HW_ID, 0)
+	VADC_CHAN_VOLT(LR_MUX8_PU2_AMUX_THM4, 0)
+	VADC_CHAN_VOLT(LR_MUX9_PU2_AMUX_THM5, 0)
+	VADC_CHAN_VOLT(LR_MUX10_PU2_AMUX_USB_ID, 0)
+	VADC_CHAN_VOLT(LR_MUX3_BUF_PU2_XO_THERM, 0)
+
+	VADC_CHAN_VOLT(LR_MUX1_PU1_PU2_BAT_THERM, 0)
+	VADC_CHAN_VOLT(LR_MUX2_PU1_PU2_BAT_ID, 0)
+	VADC_CHAN_VOLT(LR_MUX3_PU1_PU2_XO_THERM, 0)
+	VADC_CHAN_VOLT(LR_MUX4_PU1_PU2_AMUX_THM1, 0)
+	VADC_CHAN_VOLT(LR_MUX5_PU1_PU2_AMUX_THM2, 0)
+	VADC_CHAN_VOLT(LR_MUX6_PU1_PU2_AMUX_THM3, 0)
+	VADC_CHAN_VOLT(LR_MUX7_PU1_PU2_AMUX_HW_ID, 0)
+	VADC_CHAN_VOLT(LR_MUX8_PU1_PU2_AMUX_THM4, 0)
+	VADC_CHAN_VOLT(LR_MUX9_PU1_PU2_AMUX_THM5, 0)
+	VADC_CHAN_VOLT(LR_MUX10_PU1_PU2_AMUX_USB_ID, 0)
+	VADC_CHAN_VOLT(LR_MUX3_BUF_PU1_PU2_XO_THERM, 0)
+};
+
+static struct vadc_channels pmp8074_vadc_chans[] = {
+	VADC_CHAN_VOLT(PMP8074_GND_REF, 0)
+	VADC_CHAN_VOLT(PMP8074_REF_1250MV, 0)
+	VADC_CHAN_VOLT(PMP8074_VDD_VADC, 0)
+	VADC_CHAN_VOLT(PMP8074_RESERVED1, 0)
+	VADC_CHAN_VOLT(PMP8074_RESERVED2, 0)
+	VADC_CHAN_VOLT(PMP8074_RESERVED3, 0)
+	VADC_CHAN_TEMP(PMP8074_DIE_TEMP, 0)
+	VADC_CHAN_TEMP(PMP8074_CHG_TEMP, 0)
+	VADC_CHAN_VOLT(PMP8074_USBIN, 0)
+	VADC_CHAN_VOLT(PMP8074_IREG_FB, 0)
+	VADC_CHAN_VOLT(PMP8074_BAT_THERM, 0)
+	VADC_CHAN_VOLT(PMP8074_BAT_ID, 0)
+	VADC_CHAN_VOLT(PMP8074_XOTHERM, 0)
+	VADC_CHAN_VOLT(PMP8074_AMUX_THM1, 0)
+	VADC_CHAN_VOLT(PMP8074_AMUX_THM2, 0)
+	VADC_CHAN_VOLT(PMP8074_AMUX_THM3, 0)
 };
 
 static int vadc_get_dt_channel_data(struct device *dev,
 				    struct vadc_channel_prop *prop,
-				    struct device_node *node)
+				    struct device_node *node,
+				    struct vadc_channels *vadc_chans,
+				    int ch_min, int ch_max)
 {
 	const char *name = node->name;
 	u32 chan, value, varr[2];
@@ -662,7 +908,12 @@ static int vadc_get_dt_channel_data(stru
 		return ret;
 	}
 
-	if (chan > VADC_CHAN_MAX || chan < VADC_CHAN_MIN) {
+	if (!vadc_chans) {
+		dev_err(dev, "%s No channels specified.\n", name);
+		return -EINVAL;
+	}
+
+	if (chan < ch_min || chan > ch_max) {
 		dev_err(dev, "%s invalid channel number %d\n", name, chan);
 		return -EINVAL;
 	}
@@ -672,7 +923,7 @@ static int vadc_get_dt_channel_data(stru
 
 	ret = of_property_read_u32(node, "qcom,decimation", &value);
 	if (!ret) {
-		ret = qcom_vadc_decimation_from_dt(value);
+		ret = vadc_decimation_from_dt(value);
 		if (ret < 0) {
 			dev_err(dev, "%02x invalid decimation %d\n",
 				chan, value);
@@ -734,10 +985,11 @@ static int vadc_get_dt_channel_data(stru
 
 static int vadc_get_dt_data(struct vadc_priv *vadc, struct device_node *node)
 {
-	const struct vadc_channels *vadc_chan;
+	struct vadc_channels *vadc_chan;
 	struct iio_chan_spec *iio_chan;
 	struct vadc_channel_prop prop;
 	struct device_node *child;
+	struct vadc_channels *vadc_chans;
 	unsigned int index = 0;
 	int ret;
 
@@ -757,14 +1009,19 @@ static int vadc_get_dt_data(struct vadc_
 
 	iio_chan = vadc->iio_chans;
 
+	vadc_chans = vadc->dev_data->vadc_chans;
+	if (!vadc_chans)
+		return -EINVAL;
+
 	for_each_available_child_of_node(node, child) {
-		ret = vadc_get_dt_channel_data(vadc->dev, &prop, child);
+		ret = vadc_get_dt_channel_data(vadc->dev, &prop, child,
+					vadc_chans, vadc->dev_data->ch_min,
+						vadc->dev_data->ch_max);
 		if (ret) {
 			of_node_put(child);
 			return ret;
 		}
 
-		prop.scale_fn_type = vadc_chans[prop.channel].scale_fn_type;
 		vadc->chan_props[index] = prop;
 
 		vadc_chan = &vadc_chans[prop.channel];
@@ -779,25 +1036,27 @@ static int vadc_get_dt_data(struct vadc_
 		iio_chan++;
 	}
 
-	/* These channels are mandatory, they are used as reference points */
-	if (!vadc_get_channel(vadc, VADC_REF_1250MV)) {
-		dev_err(vadc->dev, "Please define 1.25V channel\n");
-		return -ENODEV;
-	}
+	if (vadc->dev_data->dynamic_calib) {
+		/* These channels are mandatory, they are used as reference points */
+		if (!vadc_get_channel(vadc, VADC_REF_1250MV)) {
+			dev_err(vadc->dev, "Please define 1.25V channel\n");
+			return -ENODEV;
+		}
 
-	if (!vadc_get_channel(vadc, VADC_REF_625MV)) {
-		dev_err(vadc->dev, "Please define 0.625V channel\n");
-		return -ENODEV;
-	}
+		if (!vadc_get_channel(vadc, VADC_REF_625MV)) {
+			dev_err(vadc->dev, "Please define 0.625V channel\n");
+			return -ENODEV;
+		}
 
-	if (!vadc_get_channel(vadc, VADC_VDD_VADC)) {
-		dev_err(vadc->dev, "Please define VDD channel\n");
-		return -ENODEV;
-	}
+		if (!vadc_get_channel(vadc, VADC_VDD_VADC)) {
+			dev_err(vadc->dev, "Please define VDD channel\n");
+			return -ENODEV;
+		}
 
-	if (!vadc_get_channel(vadc, VADC_GND_REF)) {
-		dev_err(vadc->dev, "Please define GND channel\n");
-		return -ENODEV;
+		if (!vadc_get_channel(vadc, VADC_GND_REF)) {
+			dev_err(vadc->dev, "Please define GND channel\n");
+			return -ENODEV;
+		}
 	}
 
 	return 0;
@@ -847,16 +1106,148 @@ static int vadc_check_revision(struct va
 	return 0;
 }
 
+static int pmp8074_get_temp(struct thermal_zone_device *thermal,
+			     int *temp)
+{
+	struct vadc_thermal_data *vadc_therm = thermal->devdata;
+	struct vadc_priv *vadc;
+	struct vadc_channel_prop *prop;
+	u16 adc_code;
+	int rc = 0;
+
+	if (!vadc_therm)
+		return -EINVAL;
+
+	vadc = vadc_therm->vadc_dev;
+	if (!vadc)
+		return -EINVAL;
+
+	prop = &(vadc->chan_props[vadc_therm->thermal_chan]);
+	if (!prop)
+		return -EINVAL;
+
+	rc = vadc_do_conversion(vadc, prop, &adc_code);
+	if (rc) {
+		pr_err("VADC read error with %d\n", rc);
+		return rc;
+	}
+
+	/*
+	 * Temperature = 506 â€“ (ADC_Counts * 100 /2397)
+	 */
+	*temp = PMP8074_PA_THERM_BASE
+	- ((adc_code * PMP8074_PA_THERM_FACTOR) / PMP8074_PA_THERM_SLOPE);
+
+	return rc;
+}
+
+static struct thermal_zone_device_ops pmp8074_thermal_ops = {
+	.get_temp = pmp8074_get_temp,
+};
+
+#define THERMALNODE_NAME_LENGTH	25
+static int32_t vadc_init_thermal(struct vadc_priv *vadc,
+					struct platform_device *pdev)
+{
+	struct device_node *child;
+	struct device_node *node = pdev->dev.of_node;
+	int i = 0;
+	bool thermal_node = false;
+
+	if (node == NULL)
+		goto thermal_err_sens;
+
+	if (!vadc->dev_data->thermal_ops) {
+		pr_info("No thermal ops to initialize.\n");
+		return 0;
+	}
+
+	for_each_child_of_node(node, child) {
+		char name[THERMALNODE_NAME_LENGTH];
+
+		vadc->vadc_therm_chan[i].thermal_chan = i;
+		thermal_node = of_property_read_bool(child,
+					"qcom,vadc-thermal-node");
+		if (thermal_node) {
+			/* Register with the thermal zone */
+			snprintf(name, sizeof(name), "%s", child->name);
+			vadc->vadc_therm_chan[i].vadc_dev = vadc;
+			vadc->vadc_therm_chan[i].tz_dev =
+				thermal_zone_device_register(name,
+				0, 0, &vadc->vadc_therm_chan[i],
+				vadc->dev_data->thermal_ops, NULL, 0, 0);
+			if (IS_ERR(vadc->vadc_therm_chan[i].tz_dev)) {
+				pr_err("vadc thermal device register failed.\n");
+				goto thermal_err_sens;
+			}
+		}
+		i++;
+		thermal_node = false;
+	}
+	return 0;
+thermal_err_sens:
+	pr_err("VADC thermal init failed.\n");
+	return -EINVAL;
+}
+
+static struct device_data default_data  = {
+	.vadc_chans = default_vadc_chans,
+	.reg = reg_offset_default,
+	.mode_ctl = true,
+	.dynamic_calib = true,
+	.force_decimation = true,
+	.decimation_mask = 0,
+	.ch_min = VADC_USBIN,
+	.ch_max = VADC_LR_MUX3_BUF_PU1_PU2_XO_THERM,
+	.adc_min = 0x6000,
+	.adc_max = 0xa800,
+	.uV_max = 1800000,
+	.adc_to_uV = NULL,
+	.adc_to_degc = NULL,
+	.thermal_ops = NULL,
+};
+
+static struct device_data pmp8064_data = {
+	.vadc_chans = pmp8074_vadc_chans,
+	.reg = reg_offset_pmp8074,
+	.mode_ctl = false,
+	.dynamic_calib = false,
+	.force_decimation = false,
+	.decimation_mask = 0xc,
+	.ch_min = VADC_PMP8074_GND_REF,
+	.ch_max = VADC_PMP8074_AMUX_THM3,
+	.adc_min = 0x0,
+	.adc_max = 0x4000,
+	.uV_max = 1875000,
+	.adc_to_uV = pmp8074_adc_to_uV,
+	.adc_to_degc = pmp8074_adc_to_degc,
+	.thermal_ops = &pmp8074_thermal_ops,
+};
+
+static const struct of_device_id vadc_match_table[] = {
+	{ .compatible = "qcom,spmi-vadc", .data = (void*)&default_data },
+	{ .compatible = "qcom,pmp8074-spmi-vadc", .data = (void*)&pmp8064_data },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, vadc_match_table);
+
 static int vadc_probe(struct platform_device *pdev)
 {
+	const struct of_device_id *id;
 	struct device_node *node = pdev->dev.of_node;
+	struct device_node *child;
 	struct device *dev = &pdev->dev;
 	struct iio_dev *indio_dev;
 	struct vadc_priv *vadc;
 	struct regmap *regmap;
-	int ret, irq_eoc;
+	struct vadc_thermal_data *adc_thermal;
+	int ret, irq_eoc, count_adc_channel_list = 0;
 	u32 reg;
 
+	id = of_match_device(vadc_match_table, &pdev->dev);
+        if (!id || !id->data)
+                return -ENODEV;
+
 	regmap = dev_get_regmap(dev->parent, NULL);
 	if (!regmap)
 		return -ENODEV;
@@ -865,11 +1256,30 @@ static int vadc_probe(struct platform_de
 	if (ret < 0)
 		return ret;
 
+	for_each_child_of_node(node, child)
+		count_adc_channel_list++;
+
+	if (!count_adc_channel_list) {
+		pr_err("No channel listing\n");
+		return -EINVAL;
+	}
+
 	indio_dev = devm_iio_device_alloc(dev, sizeof(*vadc));
 	if (!indio_dev)
 		return -ENOMEM;
 
 	vadc = iio_priv(indio_dev);
+
+	adc_thermal = devm_kzalloc(dev, (sizeof(struct vadc_thermal_data) *
+					count_adc_channel_list), GFP_KERNEL);
+	if (!adc_thermal)
+		return -ENOMEM;
+
+	vadc->vadc_therm_chan = adc_thermal;
+
+	vadc->dev_data = (struct device_data*)id->data;
+	pr_info("SPMI VADC - Min ch: %d Max ch: %d\n",
+			vadc->dev_data->ch_min, vadc->dev_data->ch_max);
 	vadc->regmap = regmap;
 	vadc->dev = dev;
 	vadc->base = reg;
@@ -903,9 +1313,11 @@ static int vadc_probe(struct platform_de
 		return ret;
 	}
 
-	ret = vadc_measure_ref_points(vadc);
-	if (ret)
-		return ret;
+	if ( vadc->dev_data->dynamic_calib) {
+		ret = vadc_measure_ref_points(vadc);
+		if (ret)
+			return ret;
+	}
 
 	indio_dev->dev.parent = dev;
 	indio_dev->dev.of_node = node;
@@ -915,14 +1327,20 @@ static int vadc_probe(struct platform_de
 	indio_dev->channels = vadc->iio_chans;
 	indio_dev->num_channels = vadc->nchannels;
 
-	return devm_iio_device_register(dev, indio_dev);
-}
+	ret = devm_iio_device_register(dev, indio_dev);
+	if (ret) {
+		dev_err(dev, "failed to register iio device - %d\n", ret);
+		return ret;
+	}
 
-static const struct of_device_id vadc_match_table[] = {
-	{ .compatible = "qcom,spmi-vadc" },
-	{ }
-};
-MODULE_DEVICE_TABLE(of, vadc_match_table);
+	ret = vadc_init_thermal(vadc, pdev);
+	if (ret) {
+		dev_err(dev, "failed to initialize thermal adc\n");
+		return ret;
+	}
+
+	return 0;
+}
 
 static struct platform_driver vadc_driver = {
 	.driver = {
Index: linux-5.4.52/drivers/regulator/qcom_spmi-regulator.c
===================================================================
--- linux-5.4.52.orig/drivers/regulator/qcom_spmi-regulator.c
+++ linux-5.4.52/drivers/regulator/qcom_spmi-regulator.c
@@ -1,6 +1,14 @@
-// SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  */
 
 #include <linux/module.h>
@@ -17,8 +25,6 @@
 #include <linux/regulator/driver.h>
 #include <linux/regmap.h>
 #include <linux/list.h>
-#include <linux/mfd/syscon.h>
-#include <linux/io.h>
 
 /* Pin control enable input pins. */
 #define SPMI_REGULATOR_PIN_CTRL_ENABLE_NONE		0x00
@@ -96,8 +102,6 @@ enum spmi_regulator_logical_type {
 	SPMI_REGULATOR_LOGICAL_TYPE_ULT_LO_SMPS,
 	SPMI_REGULATOR_LOGICAL_TYPE_ULT_HO_SMPS,
 	SPMI_REGULATOR_LOGICAL_TYPE_ULT_LDO,
-	SPMI_REGULATOR_LOGICAL_TYPE_FTSMPS426,
-	SPMI_REGULATOR_LOGICAL_TYPE_HFS430,
 };
 
 enum spmi_regulator_type {
@@ -144,13 +148,13 @@ enum spmi_regulator_subtype {
 	SPMI_REGULATOR_SUBTYPE_5V_BOOST		= 0x01,
 	SPMI_REGULATOR_SUBTYPE_FTS_CTL		= 0x08,
 	SPMI_REGULATOR_SUBTYPE_FTS2p5_CTL	= 0x09,
-	SPMI_REGULATOR_SUBTYPE_FTS426_CTL	= 0x0a,
 	SPMI_REGULATOR_SUBTYPE_BB_2A		= 0x01,
 	SPMI_REGULATOR_SUBTYPE_ULT_HF_CTL1	= 0x0d,
 	SPMI_REGULATOR_SUBTYPE_ULT_HF_CTL2	= 0x0e,
 	SPMI_REGULATOR_SUBTYPE_ULT_HF_CTL3	= 0x0f,
 	SPMI_REGULATOR_SUBTYPE_ULT_HF_CTL4	= 0x10,
-	SPMI_REGULATOR_SUBTYPE_HFS430		= 0x0a,
+	SPMI_REGULATOR_SUBTYPE_VMPWM_CTL	= 0x0a,
+	SPMI_REGULATOR_SUBTYPE_HT_P150		= 0x35,
 };
 
 enum spmi_common_regulator_registers {
@@ -166,18 +170,6 @@ enum spmi_common_regulator_registers {
 	SPMI_COMMON_REG_STEP_CTRL		= 0x61,
 };
 
-/*
- * Second common register layout used by newer devices starting with ftsmps426
- * Note that some of the registers from the first common layout remain
- * unchanged and their definition is not duplicated.
- */
-enum spmi_ftsmps426_regulator_registers {
-	SPMI_FTSMPS426_REG_VOLTAGE_LSB		= 0x40,
-	SPMI_FTSMPS426_REG_VOLTAGE_MSB		= 0x41,
-	SPMI_FTSMPS426_REG_VOLTAGE_ULS_LSB	= 0x68,
-	SPMI_FTSMPS426_REG_VOLTAGE_ULS_MSB	= 0x69,
-};
-
 enum spmi_vs_registers {
 	SPMI_VS_REG_OCP				= 0x4a,
 	SPMI_VS_REG_SOFT_START			= 0x4c,
@@ -191,23 +183,6 @@ enum spmi_boost_byp_registers {
 	SPMI_BOOST_BYP_REG_CURRENT_LIMIT	= 0x4b,
 };
 
-enum spmi_saw3_registers {
-	SAW3_SECURE				= 0x00,
-	SAW3_ID					= 0x04,
-	SAW3_SPM_STS				= 0x0C,
-	SAW3_AVS_STS				= 0x10,
-	SAW3_PMIC_STS				= 0x14,
-	SAW3_RST				= 0x18,
-	SAW3_VCTL				= 0x1C,
-	SAW3_AVS_CTL				= 0x20,
-	SAW3_AVS_LIMIT				= 0x24,
-	SAW3_AVS_DLY				= 0x28,
-	SAW3_AVS_HYSTERESIS			= 0x2C,
-	SAW3_SPM_STS2				= 0x38,
-	SAW3_SPM_PMIC_DATA_3			= 0x4C,
-	SAW3_VERSION				= 0xFD0,
-};
-
 /* Used for indexing into ctrl_reg.  These are offets from 0x40 */
 enum spmi_common_control_register_index {
 	SPMI_COMMON_IDX_VOLTAGE_RANGE		= 0,
@@ -237,14 +212,6 @@ enum spmi_common_control_register_index
 #define SPMI_COMMON_MODE_FOLLOW_HW_EN0_MASK	0x01
 #define SPMI_COMMON_MODE_FOLLOW_ALL_MASK	0x1f
 
-#define SPMI_FTSMPS426_MODE_BYPASS_MASK		3
-#define SPMI_FTSMPS426_MODE_RETENTION_MASK	4
-#define SPMI_FTSMPS426_MODE_LPM_MASK		5
-#define SPMI_FTSMPS426_MODE_AUTO_MASK		6
-#define SPMI_FTSMPS426_MODE_HPM_MASK		7
-
-#define SPMI_FTSMPS426_MODE_MASK		0x07
-
 /* Common regulator pull down control register layout */
 #define SPMI_COMMON_PULL_DOWN_ENABLE_MASK	0x80
 
@@ -276,6 +243,10 @@ enum spmi_common_control_register_index
 #define SPMI_FTSMPS_STEP_CTRL_DELAY_MASK	0x07
 #define SPMI_FTSMPS_STEP_CTRL_DELAY_SHIFT	0
 
+#define SPMI_SMPS_VMPWM_VSET_UB_SHIFT		8
+#define SPMI_SMPS_VMPWM_VSET_UB_MASK		0xf00
+#define SPMI_SMPS_VMPWM_VSET_LB_MASK		0xff
+
 /* Clock rate in kHz of the FTSMPS regulator reference clock. */
 #define SPMI_FTSMPS_CLOCK_RATE		19200
 
@@ -290,25 +261,6 @@ enum spmi_common_control_register_index
 #define SPMI_FTSMPS_STEP_MARGIN_NUM	4
 #define SPMI_FTSMPS_STEP_MARGIN_DEN	5
 
-#define SPMI_FTSMPS426_STEP_CTRL_DELAY_MASK	0x03
-#define SPMI_FTSMPS426_STEP_CTRL_DELAY_SHIFT	0
-
-/* Clock rate in kHz of the FTSMPS426 regulator reference clock. */
-#define SPMI_FTSMPS426_CLOCK_RATE		4800
-
-#define SPMI_HFS430_CLOCK_RATE			1600
-
-/* Minimum voltage stepper delay for each step. */
-#define SPMI_FTSMPS426_STEP_DELAY		2
-
-/*
- * The ratio SPMI_FTSMPS426_STEP_MARGIN_NUM/SPMI_FTSMPS426_STEP_MARGIN_DEN is
- * used to adjust the step rate in order to account for oscillator variance.
- */
-#define SPMI_FTSMPS426_STEP_MARGIN_NUM	10
-#define SPMI_FTSMPS426_STEP_MARGIN_DEN	11
-
-
 /* VSET value to decide the range of ULT SMPS */
 #define ULT_SMPS_RANGE_SPLIT 0x60
 
@@ -468,10 +420,16 @@ static struct spmi_voltage_range ln_ldo_
 };
 
 static struct spmi_voltage_range smps_ranges[] = {
+	SPMI_VOLTAGE_RANGE(2,  670000,  670000, 990000,  990000,  8000),
 	SPMI_VOLTAGE_RANGE(0,  375000,  375000, 1562500, 1562500, 12500),
 	SPMI_VOLTAGE_RANGE(1, 1550000, 1575000, 3125000, 3125000, 25000),
 };
 
+static struct spmi_voltage_range smps_vmpwm_ranges[] = {
+	SPMI_VOLTAGE_RANGE(0,  664000,  664000, 1104000, 1104000, 8000),
+	SPMI_VOLTAGE_RANGE(1,  1104000, 1104000, 3300000, 3300000, 8000),
+};
+
 static struct spmi_voltage_range ftsmps_ranges[] = {
 	SPMI_VOLTAGE_RANGE(0,       0,  350000, 1275000, 1275000,  5000),
 	SPMI_VOLTAGE_RANGE(1,       0, 1280000, 2040000, 2040000, 10000),
@@ -482,10 +440,6 @@ static struct spmi_voltage_range ftsmps2
 	SPMI_VOLTAGE_RANGE(1,  160000, 1360000, 2200000, 2200000, 10000),
 };
 
-static struct spmi_voltage_range ftsmps426_ranges[] = {
-	SPMI_VOLTAGE_RANGE(0,       0,  320000, 1352000, 1352000,  4000),
-};
-
 static struct spmi_voltage_range boost_ranges[] = {
 	SPMI_VOLTAGE_RANGE(0, 4000000, 4000000, 5550000, 5550000, 50000),
 };
@@ -511,26 +465,21 @@ static struct spmi_voltage_range ult_pld
 	SPMI_VOLTAGE_RANGE(0, 1750000, 1750000, 3337500, 3337500, 12500),
 };
 
-static struct spmi_voltage_range hfs430_ranges[] = {
-	SPMI_VOLTAGE_RANGE(0, 320000, 320000, 2040000, 2040000, 8000),
-};
-
 static DEFINE_SPMI_SET_POINTS(pldo);
 static DEFINE_SPMI_SET_POINTS(nldo1);
 static DEFINE_SPMI_SET_POINTS(nldo2);
 static DEFINE_SPMI_SET_POINTS(nldo3);
 static DEFINE_SPMI_SET_POINTS(ln_ldo);
 static DEFINE_SPMI_SET_POINTS(smps);
+static DEFINE_SPMI_SET_POINTS(smps_vmpwm);
 static DEFINE_SPMI_SET_POINTS(ftsmps);
 static DEFINE_SPMI_SET_POINTS(ftsmps2p5);
-static DEFINE_SPMI_SET_POINTS(ftsmps426);
 static DEFINE_SPMI_SET_POINTS(boost);
 static DEFINE_SPMI_SET_POINTS(boost_byp);
 static DEFINE_SPMI_SET_POINTS(ult_lo_smps);
 static DEFINE_SPMI_SET_POINTS(ult_ho_smps);
 static DEFINE_SPMI_SET_POINTS(ult_nldo);
 static DEFINE_SPMI_SET_POINTS(ult_pldo);
-static DEFINE_SPMI_SET_POINTS(hfs430);
 
 static inline int spmi_vreg_read(struct spmi_regulator *vreg, u16 addr, u8 *buf,
 				 int len)
@@ -550,6 +499,24 @@ static int spmi_vreg_update_bits(struct
 	return regmap_update_bits(vreg->regmap, vreg->base + addr, mask, val);
 }
 
+static int spmi_regulator_common_is_enabled(struct regulator_dev *rdev)
+{
+	struct spmi_regulator *vreg = rdev_get_drvdata(rdev);
+	u8 reg;
+
+	spmi_vreg_read(vreg, SPMI_COMMON_REG_ENABLE, &reg, 1);
+
+	return (reg & SPMI_COMMON_ENABLE_MASK) == SPMI_COMMON_ENABLE;
+}
+
+static int spmi_regulator_common_enable(struct regulator_dev *rdev)
+{
+	struct spmi_regulator *vreg = rdev_get_drvdata(rdev);
+
+	return spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_ENABLE,
+		SPMI_COMMON_ENABLE, SPMI_COMMON_ENABLE_MASK);
+}
+
 static int spmi_regulator_vs_enable(struct regulator_dev *rdev)
 {
 	struct spmi_regulator *vreg = rdev_get_drvdata(rdev);
@@ -559,7 +526,7 @@ static int spmi_regulator_vs_enable(stru
 		vreg->vs_enable_time = ktime_get();
 	}
 
-	return regulator_enable_regmap(rdev);
+	return spmi_regulator_common_enable(rdev);
 }
 
 static int spmi_regulator_vs_ocp(struct regulator_dev *rdev)
@@ -570,6 +537,14 @@ static int spmi_regulator_vs_ocp(struct
 	return spmi_vreg_write(vreg, SPMI_VS_REG_OCP, &reg, 1);
 }
 
+static int spmi_regulator_common_disable(struct regulator_dev *rdev)
+{
+	struct spmi_regulator *vreg = rdev_get_drvdata(rdev);
+
+	return spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_ENABLE,
+		SPMI_COMMON_DISABLE, SPMI_COMMON_ENABLE_MASK);
+}
+
 static int spmi_regulator_select_voltage(struct spmi_regulator *vreg,
 					 int min_uV, int max_uV)
 {
@@ -631,20 +606,13 @@ static int spmi_sw_selector_to_hw(struct
 				  u8 *voltage_sel)
 {
 	const struct spmi_voltage_range *range, *end;
-	unsigned offset;
 
 	range = vreg->set_points->range;
 	end = range + vreg->set_points->count;
 
 	for (; range < end; range++) {
 		if (selector < range->n_voltages) {
-			/*
-			 * hardware selectors between set point min and real
-			 * min are invalid so we ignore them
-			 */
-			offset = range->set_point_min_uV - range->min_uV;
-			offset /= range->step_uV;
-			*voltage_sel = selector + offset;
+			*voltage_sel = selector;
 			*range_sel = range->range_sel;
 			return 0;
 		}
@@ -658,35 +626,15 @@ static int spmi_sw_selector_to_hw(struct
 static int spmi_hw_selector_to_sw(struct spmi_regulator *vreg, u8 hw_sel,
 				  const struct spmi_voltage_range *range)
 {
-	unsigned sw_sel = 0;
-	unsigned offset, max_hw_sel;
+	int sw_sel = hw_sel;
 	const struct spmi_voltage_range *r = vreg->set_points->range;
-	const struct spmi_voltage_range *end = r + vreg->set_points->count;
-
-	for (; r < end; r++) {
-		if (r == range && range->n_voltages) {
-			/*
-			 * hardware selectors between set point min and real
-			 * min and between set point max and real max are
-			 * invalid so we return an error if they're
-			 * programmed into the hardware
-			 */
-			offset = range->set_point_min_uV - range->min_uV;
-			offset /= range->step_uV;
-			if (hw_sel < offset)
-				return -EINVAL;
-
-			max_hw_sel = range->set_point_max_uV - range->min_uV;
-			max_hw_sel /= range->step_uV;
-			if (hw_sel > max_hw_sel)
-				return -EINVAL;
 
-			return sw_sel + hw_sel - offset;
-		}
+	while (r != range) {
 		sw_sel += r->n_voltages;
+		r++;
 	}
 
-	return -EINVAL;
+	return sw_sel;
 }
 
 static const struct spmi_voltage_range *
@@ -707,6 +655,24 @@ spmi_regulator_find_range(struct spmi_re
 	return NULL;
 }
 
+static const struct spmi_voltage_range *
+spmi_regulator_find_uV_range(struct spmi_regulator *vreg, int min, int max)
+{
+	const struct spmi_voltage_range *range, *end;
+
+	if (!vreg->set_points || !vreg->set_points->count)
+		return 0;
+
+	range = vreg->set_points->range;
+	end = range + vreg->set_points->count;
+
+	for (; range < end; range++)
+		if ((range->min_uV <= min) && (range->max_uV >= max))
+			return range;
+
+	return 0;
+}
+
 static int spmi_regulator_select_voltage_same_range(struct spmi_regulator *vreg,
 		int min_uV, int max_uV)
 {
@@ -792,31 +758,18 @@ spmi_regulator_common_set_voltage(struct
 	return spmi_vreg_write(vreg, SPMI_COMMON_REG_VOLTAGE_RANGE, buf, 2);
 }
 
-static int spmi_regulator_common_list_voltage(struct regulator_dev *rdev,
-					      unsigned selector);
-
-static int spmi_regulator_ftsmps426_set_voltage(struct regulator_dev *rdev,
-					      unsigned selector)
-{
-	struct spmi_regulator *vreg = rdev_get_drvdata(rdev);
-	u8 buf[2];
-	int mV;
-
-	mV = spmi_regulator_common_list_voltage(rdev, selector) / 1000;
-
-	buf[0] = mV & 0xff;
-	buf[1] = mV >> 8;
-	return spmi_vreg_write(vreg, SPMI_FTSMPS426_REG_VOLTAGE_LSB, buf, 2);
-}
-
 static int spmi_regulator_set_voltage_time_sel(struct regulator_dev *rdev,
 		unsigned int old_selector, unsigned int new_selector)
 {
 	struct spmi_regulator *vreg = rdev_get_drvdata(rdev);
+	const struct spmi_voltage_range *range;
 	int diff_uV;
 
-	diff_uV = abs(spmi_regulator_common_list_voltage(rdev, new_selector) -
-		      spmi_regulator_common_list_voltage(rdev, old_selector));
+	range = spmi_regulator_find_range(vreg);
+	if (!range)
+		return -EINVAL;
+
+	diff_uV = abs(new_selector - old_selector) * range->step_uV;
 
 	return DIV_ROUND_UP(diff_uV, vreg->slew_rate);
 }
@@ -836,21 +789,6 @@ static int spmi_regulator_common_get_vol
 	return spmi_hw_selector_to_sw(vreg, voltage_sel, range);
 }
 
-static int spmi_regulator_ftsmps426_get_voltage(struct regulator_dev *rdev)
-{
-	struct spmi_regulator *vreg = rdev_get_drvdata(rdev);
-	const struct spmi_voltage_range *range;
-	u8 buf[2];
-	int uV;
-
-	spmi_vreg_read(vreg, SPMI_FTSMPS426_REG_VOLTAGE_LSB, buf, 2);
-
-	uV = (((unsigned int)buf[1] << 8) | (unsigned int)buf[0]) * 1000;
-	range = vreg->set_points->range;
-
-	return (uV - range->set_point_min_uV) / range->step_uV;
-}
-
 static int spmi_regulator_single_map_voltage(struct regulator_dev *rdev,
 		int min_uV, int max_uV)
 {
@@ -928,6 +866,47 @@ static int spmi_regulator_ult_lo_smps_ge
 	return spmi_hw_selector_to_sw(vreg, voltage_sel, range);
 }
 
+static int spmi_regulator_smps_vmpwm_set_vol_uV(struct regulator_dev *rdev,
+				int min_uV, int max_uV, unsigned *selector)
+{
+	struct spmi_regulator *vreg = rdev_get_drvdata(rdev);
+	const struct spmi_voltage_range *range;
+	int req_vol;
+	u8 reg[2];
+
+	range = spmi_regulator_find_uV_range(vreg, min_uV, max_uV);
+	if (!range)
+		return -EINVAL;
+
+	*selector = spmi_regulator_select_voltage(vreg, min_uV, max_uV);
+	req_vol = range->set_point_min_uV + (range->step_uV * (*selector));
+
+	/* Convert uV to mV as the register supports mV */
+	req_vol = req_vol/1000;
+
+	/*
+	 * Voltage set point bits<7:0>. 2-Byte Word (lower byte word)
+	 */
+	reg[0] = req_vol & SPMI_SMPS_VMPWM_VSET_LB_MASK;
+	/*
+	 * Voltage set point bit <11:8>. 2-Byte Word (upper byte word)
+	 */
+	reg[1] = (req_vol & SPMI_SMPS_VMPWM_VSET_UB_MASK)
+			>> SPMI_SMPS_VMPWM_VSET_UB_SHIFT;
+
+	return spmi_vreg_write(vreg, SPMI_COMMON_REG_VOLTAGE_RANGE, reg, 2);
+}
+
+static int spmi_regulator_smps_vmpwm_get_vol_uV(struct regulator_dev *rdev)
+{
+	struct spmi_regulator *vreg = rdev_get_drvdata(rdev);
+	u8 reg[2];
+
+	spmi_vreg_read(vreg, SPMI_COMMON_REG_VOLTAGE_RANGE, reg, 2);
+
+	return ((reg[1] << SPMI_SMPS_VMPWM_VSET_UB_SHIFT) | reg[0]) * 1000;
+}
+
 static int spmi_regulator_common_list_voltage(struct regulator_dev *rdev,
 			unsigned selector)
 {
@@ -984,33 +963,13 @@ static unsigned int spmi_regulator_commo
 
 	spmi_vreg_read(vreg, SPMI_COMMON_REG_MODE, &reg, 1);
 
-	reg &= SPMI_COMMON_MODE_HPM_MASK | SPMI_COMMON_MODE_AUTO_MASK;
-
-	switch (reg) {
-	case SPMI_COMMON_MODE_HPM_MASK:
+	if (reg & SPMI_COMMON_MODE_HPM_MASK)
 		return REGULATOR_MODE_NORMAL;
-	case SPMI_COMMON_MODE_AUTO_MASK:
-		return REGULATOR_MODE_FAST;
-	default:
-		return REGULATOR_MODE_IDLE;
-	}
-}
-
-static unsigned int spmi_regulator_ftsmps426_get_mode(struct regulator_dev *rdev)
-{
-	struct spmi_regulator *vreg = rdev_get_drvdata(rdev);
-	u8 reg;
-
-	spmi_vreg_read(vreg, SPMI_COMMON_REG_MODE, &reg, 1);
 
-	switch (reg) {
-	case SPMI_FTSMPS426_MODE_HPM_MASK:
-		return REGULATOR_MODE_NORMAL;
-	case SPMI_FTSMPS426_MODE_AUTO_MASK:
+	if (reg & SPMI_COMMON_MODE_AUTO_MASK)
 		return REGULATOR_MODE_FAST;
-	default:
-		return REGULATOR_MODE_IDLE;
-	}
+
+	return REGULATOR_MODE_IDLE;
 }
 
 static int
@@ -1018,43 +977,12 @@ spmi_regulator_common_set_mode(struct re
 {
 	struct spmi_regulator *vreg = rdev_get_drvdata(rdev);
 	u8 mask = SPMI_COMMON_MODE_HPM_MASK | SPMI_COMMON_MODE_AUTO_MASK;
-	u8 val;
+	u8 val = 0;
 
-	switch (mode) {
-	case REGULATOR_MODE_NORMAL:
+	if (mode == REGULATOR_MODE_NORMAL)
 		val = SPMI_COMMON_MODE_HPM_MASK;
-		break;
-	case REGULATOR_MODE_FAST:
+	else if (mode == REGULATOR_MODE_FAST)
 		val = SPMI_COMMON_MODE_AUTO_MASK;
-		break;
-	default:
-		val = 0;
-		break;
-	}
-
-	return spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_MODE, val, mask);
-}
-
-static int
-spmi_regulator_ftsmps426_set_mode(struct regulator_dev *rdev, unsigned int mode)
-{
-	struct spmi_regulator *vreg = rdev_get_drvdata(rdev);
-	u8 mask = SPMI_FTSMPS426_MODE_MASK;
-	u8 val;
-
-	switch (mode) {
-	case REGULATOR_MODE_NORMAL:
-		val = SPMI_FTSMPS426_MODE_HPM_MASK;
-		break;
-	case REGULATOR_MODE_FAST:
-		val = SPMI_FTSMPS426_MODE_AUTO_MASK;
-		break;
-	case REGULATOR_MODE_IDLE:
-		val = SPMI_FTSMPS426_MODE_LPM_MASK;
-		break;
-	default:
-		return -EINVAL;
-	}
 
 	return spmi_vreg_update_bits(vreg, SPMI_COMMON_REG_MODE, val, mask);
 }
@@ -1178,93 +1106,10 @@ static irqreturn_t spmi_regulator_vs_ocp
 	return IRQ_HANDLED;
 }
 
-#define SAW3_VCTL_DATA_MASK	0xFF
-#define SAW3_VCTL_CLEAR_MASK	0x700FF
-#define SAW3_AVS_CTL_EN_MASK	0x1
-#define SAW3_AVS_CTL_TGGL_MASK	0x8000000
-#define SAW3_AVS_CTL_CLEAR_MASK	0x7efc00
-
-static struct regmap *saw_regmap;
-
-static void spmi_saw_set_vdd(void *data)
-{
-	u32 vctl, data3, avs_ctl, pmic_sts;
-	bool avs_enabled = false;
-	unsigned long timeout;
-	u8 voltage_sel = *(u8 *)data;
-
-	regmap_read(saw_regmap, SAW3_AVS_CTL, &avs_ctl);
-	regmap_read(saw_regmap, SAW3_VCTL, &vctl);
-	regmap_read(saw_regmap, SAW3_SPM_PMIC_DATA_3, &data3);
-
-	/* select the band */
-	vctl &= ~SAW3_VCTL_CLEAR_MASK;
-	vctl |= (u32)voltage_sel;
-
-	data3 &= ~SAW3_VCTL_CLEAR_MASK;
-	data3 |= (u32)voltage_sel;
-
-	/* If AVS is enabled, switch it off during the voltage change */
-	avs_enabled = SAW3_AVS_CTL_EN_MASK & avs_ctl;
-	if (avs_enabled) {
-		avs_ctl &= ~SAW3_AVS_CTL_TGGL_MASK;
-		regmap_write(saw_regmap, SAW3_AVS_CTL, avs_ctl);
-	}
-
-	regmap_write(saw_regmap, SAW3_RST, 1);
-	regmap_write(saw_regmap, SAW3_VCTL, vctl);
-	regmap_write(saw_regmap, SAW3_SPM_PMIC_DATA_3, data3);
-
-	timeout = jiffies + usecs_to_jiffies(100);
-	do {
-		regmap_read(saw_regmap, SAW3_PMIC_STS, &pmic_sts);
-		pmic_sts &= SAW3_VCTL_DATA_MASK;
-		if (pmic_sts == (u32)voltage_sel)
-			break;
-
-		cpu_relax();
-
-	} while (time_before(jiffies, timeout));
-
-	/* After successful voltage change, switch the AVS back on */
-	if (avs_enabled) {
-		pmic_sts &= 0x3f;
-		avs_ctl &= ~SAW3_AVS_CTL_CLEAR_MASK;
-		avs_ctl |= ((pmic_sts - 4) << 10);
-		avs_ctl |= (pmic_sts << 17);
-		avs_ctl |= SAW3_AVS_CTL_TGGL_MASK;
-		regmap_write(saw_regmap, SAW3_AVS_CTL, avs_ctl);
-	}
-}
-
-static int
-spmi_regulator_saw_set_voltage(struct regulator_dev *rdev, unsigned selector)
-{
-	struct spmi_regulator *vreg = rdev_get_drvdata(rdev);
-	int ret;
-	u8 range_sel, voltage_sel;
-
-	ret = spmi_sw_selector_to_hw(vreg, selector, &range_sel, &voltage_sel);
-	if (ret)
-		return ret;
-
-	if (0 != range_sel) {
-		dev_dbg(&rdev->dev, "range_sel = %02X voltage_sel = %02X", \
-			range_sel, voltage_sel);
-		return -EINVAL;
-	}
-
-	/* Always do the SAW register writes on the first CPU */
-	return smp_call_function_single(0, spmi_saw_set_vdd, \
-					&voltage_sel, true);
-}
-
-static struct regulator_ops spmi_saw_ops = {};
-
 static struct regulator_ops spmi_smps_ops = {
-	.enable			= regulator_enable_regmap,
-	.disable		= regulator_disable_regmap,
-	.is_enabled		= regulator_is_enabled_regmap,
+	.enable			= spmi_regulator_common_enable,
+	.disable		= spmi_regulator_common_disable,
+	.is_enabled		= spmi_regulator_common_is_enabled,
 	.set_voltage_sel	= spmi_regulator_common_set_voltage,
 	.set_voltage_time_sel	= spmi_regulator_set_voltage_time_sel,
 	.get_voltage_sel	= spmi_regulator_common_get_voltage,
@@ -1276,10 +1121,22 @@ static struct regulator_ops spmi_smps_op
 	.set_pull_down		= spmi_regulator_common_set_pull_down,
 };
 
+static struct regulator_ops spmi_smps_vmpwm_ops = {
+	.enable			= spmi_regulator_common_enable,
+	.disable		= spmi_regulator_common_disable,
+	.is_enabled		= spmi_regulator_common_is_enabled,
+	.set_voltage		= spmi_regulator_smps_vmpwm_set_vol_uV,
+	.get_voltage		= spmi_regulator_smps_vmpwm_get_vol_uV,
+	.map_voltage		= spmi_regulator_common_map_voltage,
+	.list_voltage		= spmi_regulator_common_list_voltage,
+	.set_mode		= spmi_regulator_common_set_mode,
+	.get_mode		= spmi_regulator_common_get_mode,
+};
+
 static struct regulator_ops spmi_ldo_ops = {
-	.enable			= regulator_enable_regmap,
-	.disable		= regulator_disable_regmap,
-	.is_enabled		= regulator_is_enabled_regmap,
+	.enable			= spmi_regulator_common_enable,
+	.disable		= spmi_regulator_common_disable,
+	.is_enabled		= spmi_regulator_common_is_enabled,
 	.set_voltage_sel	= spmi_regulator_common_set_voltage,
 	.get_voltage_sel	= spmi_regulator_common_get_voltage,
 	.map_voltage		= spmi_regulator_common_map_voltage,
@@ -1294,9 +1151,9 @@ static struct regulator_ops spmi_ldo_ops
 };
 
 static struct regulator_ops spmi_ln_ldo_ops = {
-	.enable			= regulator_enable_regmap,
-	.disable		= regulator_disable_regmap,
-	.is_enabled		= regulator_is_enabled_regmap,
+	.enable			= spmi_regulator_common_enable,
+	.disable		= spmi_regulator_common_disable,
+	.is_enabled		= spmi_regulator_common_is_enabled,
 	.set_voltage_sel	= spmi_regulator_common_set_voltage,
 	.get_voltage_sel	= spmi_regulator_common_get_voltage,
 	.map_voltage		= spmi_regulator_common_map_voltage,
@@ -1307,8 +1164,8 @@ static struct regulator_ops spmi_ln_ldo_
 
 static struct regulator_ops spmi_vs_ops = {
 	.enable			= spmi_regulator_vs_enable,
-	.disable		= regulator_disable_regmap,
-	.is_enabled		= regulator_is_enabled_regmap,
+	.disable		= spmi_regulator_common_disable,
+	.is_enabled		= spmi_regulator_common_is_enabled,
 	.set_pull_down		= spmi_regulator_common_set_pull_down,
 	.set_soft_start		= spmi_regulator_common_set_soft_start,
 	.set_over_current_protection = spmi_regulator_vs_ocp,
@@ -1317,9 +1174,9 @@ static struct regulator_ops spmi_vs_ops
 };
 
 static struct regulator_ops spmi_boost_ops = {
-	.enable			= regulator_enable_regmap,
-	.disable		= regulator_disable_regmap,
-	.is_enabled		= regulator_is_enabled_regmap,
+	.enable			= spmi_regulator_common_enable,
+	.disable		= spmi_regulator_common_disable,
+	.is_enabled		= spmi_regulator_common_is_enabled,
 	.set_voltage_sel	= spmi_regulator_single_range_set_voltage,
 	.get_voltage_sel	= spmi_regulator_single_range_get_voltage,
 	.map_voltage		= spmi_regulator_single_map_voltage,
@@ -1328,9 +1185,9 @@ static struct regulator_ops spmi_boost_o
 };
 
 static struct regulator_ops spmi_ftsmps_ops = {
-	.enable			= regulator_enable_regmap,
-	.disable		= regulator_disable_regmap,
-	.is_enabled		= regulator_is_enabled_regmap,
+	.enable			= spmi_regulator_common_enable,
+	.disable		= spmi_regulator_common_disable,
+	.is_enabled		= spmi_regulator_common_is_enabled,
 	.set_voltage_sel	= spmi_regulator_common_set_voltage,
 	.set_voltage_time_sel	= spmi_regulator_set_voltage_time_sel,
 	.get_voltage_sel	= spmi_regulator_common_get_voltage,
@@ -1343,9 +1200,9 @@ static struct regulator_ops spmi_ftsmps_
 };
 
 static struct regulator_ops spmi_ult_lo_smps_ops = {
-	.enable			= regulator_enable_regmap,
-	.disable		= regulator_disable_regmap,
-	.is_enabled		= regulator_is_enabled_regmap,
+	.enable			= spmi_regulator_common_enable,
+	.disable		= spmi_regulator_common_disable,
+	.is_enabled		= spmi_regulator_common_is_enabled,
 	.set_voltage_sel	= spmi_regulator_ult_lo_smps_set_voltage,
 	.set_voltage_time_sel	= spmi_regulator_set_voltage_time_sel,
 	.get_voltage_sel	= spmi_regulator_ult_lo_smps_get_voltage,
@@ -1357,9 +1214,9 @@ static struct regulator_ops spmi_ult_lo_
 };
 
 static struct regulator_ops spmi_ult_ho_smps_ops = {
-	.enable			= regulator_enable_regmap,
-	.disable		= regulator_disable_regmap,
-	.is_enabled		= regulator_is_enabled_regmap,
+	.enable			= spmi_regulator_common_enable,
+	.disable		= spmi_regulator_common_disable,
+	.is_enabled		= spmi_regulator_common_is_enabled,
 	.set_voltage_sel	= spmi_regulator_single_range_set_voltage,
 	.set_voltage_time_sel	= spmi_regulator_set_voltage_time_sel,
 	.get_voltage_sel	= spmi_regulator_single_range_get_voltage,
@@ -1372,9 +1229,9 @@ static struct regulator_ops spmi_ult_ho_
 };
 
 static struct regulator_ops spmi_ult_ldo_ops = {
-	.enable			= regulator_enable_regmap,
-	.disable		= regulator_disable_regmap,
-	.is_enabled		= regulator_is_enabled_regmap,
+	.enable			= spmi_regulator_common_enable,
+	.disable		= spmi_regulator_common_disable,
+	.is_enabled		= spmi_regulator_common_is_enabled,
 	.set_voltage_sel	= spmi_regulator_single_range_set_voltage,
 	.get_voltage_sel	= spmi_regulator_single_range_get_voltage,
 	.map_voltage		= spmi_regulator_single_map_voltage,
@@ -1388,41 +1245,14 @@ static struct regulator_ops spmi_ult_ldo
 	.set_soft_start		= spmi_regulator_common_set_soft_start,
 };
 
-static struct regulator_ops spmi_ftsmps426_ops = {
-	.enable			= regulator_enable_regmap,
-	.disable		= regulator_disable_regmap,
-	.is_enabled		= regulator_is_enabled_regmap,
-	.set_voltage_sel	= spmi_regulator_ftsmps426_set_voltage,
-	.set_voltage_time_sel	= spmi_regulator_set_voltage_time_sel,
-	.get_voltage_sel	= spmi_regulator_ftsmps426_get_voltage,
-	.map_voltage		= spmi_regulator_single_map_voltage,
-	.list_voltage		= spmi_regulator_common_list_voltage,
-	.set_mode		= spmi_regulator_ftsmps426_set_mode,
-	.get_mode		= spmi_regulator_ftsmps426_get_mode,
-	.set_load		= spmi_regulator_common_set_load,
-	.set_pull_down		= spmi_regulator_common_set_pull_down,
-};
-
-static struct regulator_ops spmi_hfs430_ops = {
-	.enable			= regulator_enable_regmap,
-	.disable		= regulator_disable_regmap,
-	.is_enabled		= regulator_is_enabled_regmap,
-	.set_voltage_sel	= spmi_regulator_ftsmps426_set_voltage,
-	.set_voltage_time_sel	= spmi_regulator_set_voltage_time_sel,
-	.get_voltage_sel	= spmi_regulator_ftsmps426_get_voltage,
-	.map_voltage		= spmi_regulator_single_map_voltage,
-	.list_voltage		= spmi_regulator_common_list_voltage,
-	.set_mode		= spmi_regulator_ftsmps426_set_mode,
-	.get_mode		= spmi_regulator_ftsmps426_get_mode,
-};
-
 /* Maximum possible digital major revision value */
 #define INF 0xFF
 
 static const struct spmi_regulator_mapping supported_regulators[] = {
 	/*           type subtype dig_min dig_max ltype ops setpoints hpm_min */
+	SPMI_VREG(LDO,  HT_P150, 0, INF, LDO, smps_vmpwm, smps_vmpwm, 0),
+	SPMI_VREG(BUCK,  VMPWM_CTL, 0, INF, SMPS, smps_vmpwm, smps_vmpwm, 0),
 	SPMI_VREG(BUCK,  GP_CTL,   0, INF, SMPS,   smps,   smps,   100000),
-	SPMI_VREG(BUCK,  HFS430,   0, INF, HFS430, hfs430, hfs430,  10000),
 	SPMI_VREG(LDO,   N300,     0, INF, LDO,    ldo,    nldo1,   10000),
 	SPMI_VREG(LDO,   N600,     0,   0, LDO,    ldo,    nldo2,   10000),
 	SPMI_VREG(LDO,   N1200,    0,   0, LDO,    ldo,    nldo2,   10000),
@@ -1452,7 +1282,6 @@ static const struct spmi_regulator_mappi
 	SPMI_VREG(BOOST, 5V_BOOST, 0, INF, BOOST,  boost,  boost,       0),
 	SPMI_VREG(FTS,   FTS_CTL,  0, INF, FTSMPS, ftsmps, ftsmps, 100000),
 	SPMI_VREG(FTS, FTS2p5_CTL, 0, INF, FTSMPS, ftsmps, ftsmps2p5, 100000),
-	SPMI_VREG(FTS, FTS426_CTL, 0, INF, FTSMPS426, ftsmps426, ftsmps426, 100000),
 	SPMI_VREG(BOOST_BYP, BB_2A, 0, INF, BOOST_BYP, boost, boost_byp, 0),
 	SPMI_VREG(ULT_BUCK, ULT_HF_CTL1, 0, INF, ULT_LO_SMPS, ult_lo_smps,
 						ult_lo_smps,   100000),
@@ -1506,7 +1335,6 @@ static int spmi_regulator_match(struct s
 	}
 	dig_major_rev	= version[SPMI_COMMON_REG_DIG_MAJOR_REV
 					- SPMI_COMMON_REG_DIG_MAJOR_REV];
-
 	if (!force_type) {
 		type		= version[SPMI_COMMON_REG_TYPE -
 					  SPMI_COMMON_REG_DIG_MAJOR_REV];
@@ -1553,6 +1381,13 @@ static int spmi_regulator_init_slew_rate
 	int step, delay, slew_rate, step_delay;
 	const struct spmi_voltage_range *range;
 
+	/*
+	 * Slew rate need not be initialized if
+	 * set_voltage_time_sel in the ops is not defined.
+	 */
+	if (!vreg->desc.ops->set_voltage_time_sel)
+		return 0;
+
 	ret = spmi_vreg_read(vreg, SPMI_COMMON_REG_STEP_CTRL, &reg, 1);
 	if (ret) {
 		dev_err(vreg->dev, "spmi read failed, ret=%d\n", ret);
@@ -1590,35 +1425,6 @@ static int spmi_regulator_init_slew_rate
 	return ret;
 }
 
-static int spmi_regulator_init_slew_rate_ftsmps426(struct spmi_regulator *vreg,
-						   int clock_rate)
-{
-	int ret;
-	u8 reg = 0;
-	int delay, slew_rate;
-	const struct spmi_voltage_range *range = &vreg->set_points->range[0];
-
-	ret = spmi_vreg_read(vreg, SPMI_COMMON_REG_STEP_CTRL, &reg, 1);
-	if (ret) {
-		dev_err(vreg->dev, "spmi read failed, ret=%d\n", ret);
-		return ret;
-	}
-
-	delay = reg & SPMI_FTSMPS426_STEP_CTRL_DELAY_MASK;
-	delay >>= SPMI_FTSMPS426_STEP_CTRL_DELAY_SHIFT;
-
-	/* slew_rate has units of uV/us */
-	slew_rate = clock_rate * range->step_uV;
-	slew_rate /= 1000 * (SPMI_FTSMPS426_STEP_DELAY << delay);
-	slew_rate *= SPMI_FTSMPS426_STEP_MARGIN_NUM;
-	slew_rate /= SPMI_FTSMPS426_STEP_MARGIN_DEN;
-
-	/* Ensure that the slew rate is greater than 0 */
-	vreg->slew_rate = max(slew_rate, 1);
-
-	return ret;
-}
-
 static int spmi_regulator_init_registers(struct spmi_regulator *vreg,
 				const struct spmi_regulator_init_data *data)
 {
@@ -1758,19 +1564,6 @@ static int spmi_regulator_of_parse(struc
 		ret = spmi_regulator_init_slew_rate(vreg);
 		if (ret)
 			return ret;
-		break;
-	case SPMI_REGULATOR_LOGICAL_TYPE_FTSMPS426:
-		ret = spmi_regulator_init_slew_rate_ftsmps426(vreg,
-						SPMI_FTSMPS426_CLOCK_RATE);
-		if (ret)
-			return ret;
-		break;
-	case SPMI_REGULATOR_LOGICAL_TYPE_HFS430:
-		ret = spmi_regulator_init_slew_rate_ftsmps426(vreg,
-							SPMI_HFS430_CLOCK_RATE);
-		if (ret)
-			return ret;
-		break;
 	default:
 		break;
 	}
@@ -1869,85 +1662,30 @@ static const struct spmi_regulator_data
 	{ }
 };
 
-static const struct spmi_regulator_data pm8994_regulators[] = {
-	{ "s1", 0x1400, "vdd_s1", },
-	{ "s2", 0x1700, "vdd_s2", },
-	{ "s3", 0x1a00, "vdd_s3", },
-	{ "s4", 0x1d00, "vdd_s4", },
-	{ "s5", 0x2000, "vdd_s5", },
-	{ "s6", 0x2300, "vdd_s6", },
-	{ "s7", 0x2600, "vdd_s7", },
-	{ "s8", 0x2900, "vdd_s8", },
-	{ "s9", 0x2c00, "vdd_s9", },
-	{ "s10", 0x2f00, "vdd_s10", },
-	{ "s11", 0x3200, "vdd_s11", },
-	{ "s12", 0x3500, "vdd_s12", },
-	{ "l1", 0x4000, "vdd_l1", },
-	{ "l2", 0x4100, "vdd_l2_l26_l28", },
-	{ "l3", 0x4200, "vdd_l3_l11", },
-	{ "l4", 0x4300, "vdd_l4_l27_l31", },
-	{ "l5", 0x4400, "vdd_l5_l7", },
-	{ "l6", 0x4500, "vdd_l6_l12_l32", },
-	{ "l7", 0x4600, "vdd_l5_l7", },
-	{ "l8", 0x4700, "vdd_l8_l16_l30", },
-	{ "l9", 0x4800, "vdd_l9_l10_l18_l22", },
-	{ "l10", 0x4900, "vdd_l9_l10_l18_l22", },
-	{ "l11", 0x4a00, "vdd_l3_l11", },
-	{ "l12", 0x4b00, "vdd_l6_l12_l32", },
-	{ "l13", 0x4c00, "vdd_l13_l19_l23_l24", },
-	{ "l14", 0x4d00, "vdd_l14_l15", },
-	{ "l15", 0x4e00, "vdd_l14_l15", },
-	{ "l16", 0x4f00, "vdd_l8_l16_l30", },
-	{ "l17", 0x5000, "vdd_l17_l29", },
-	{ "l18", 0x5100, "vdd_l9_l10_l18_l22", },
-	{ "l19", 0x5200, "vdd_l13_l19_l23_l24", },
-	{ "l20", 0x5300, "vdd_l20_l21", },
-	{ "l21", 0x5400, "vdd_l20_l21", },
-	{ "l22", 0x5500, "vdd_l9_l10_l18_l22", },
-	{ "l23", 0x5600, "vdd_l13_l19_l23_l24", },
-	{ "l24", 0x5700, "vdd_l13_l19_l23_l24", },
-	{ "l25", 0x5800, "vdd_l25", },
-	{ "l26", 0x5900, "vdd_l2_l26_l28", },
-	{ "l27", 0x5a00, "vdd_l4_l27_l31", },
-	{ "l28", 0x5b00, "vdd_l2_l26_l28", },
-	{ "l29", 0x5c00, "vdd_l17_l29", },
-	{ "l30", 0x5d00, "vdd_l8_l16_l30", },
-	{ "l31", 0x5e00, "vdd_l4_l27_l31", },
-	{ "l32", 0x5f00, "vdd_l6_l12_l32", },
-	{ "lvs1", 0x8000, "vdd_lvs_1_2", },
-	{ "lvs2", 0x8100, "vdd_lvs_1_2", },
-	{ }
-};
-
-static const struct spmi_regulator_data pmi8994_regulators[] = {
-	{ "s1", 0x1400, "vdd_s1", },
-	{ "s2", 0x1700, "vdd_s2", },
-	{ "s3", 0x1a00, "vdd_s3", },
-	{ "l1", 0x4000, "vdd_l1", },
-	{ }
-};
-
-static const struct spmi_regulator_data pm8005_regulators[] = {
-	{ "s1", 0x1400, "vdd_s1", },
-	{ "s2", 0x1700, "vdd_s2", },
-	{ "s3", 0x1a00, "vdd_s3", },
-	{ "s4", 0x1d00, "vdd_s4", },
-	{ }
-};
-
-static const struct spmi_regulator_data pms405_regulators[] = {
-	{ "s3", 0x1a00, "vdd_s3"},
+static const struct spmi_regulator_data pmd9655_regulators[] = {
+	{ "s3", 0x1a00, "vdd_s3",},
+	{ "s4", 0x1d00, "vdd_s4",},
+	{ "ldo11", 0x4a00, "vdd_ldo11",},
 	{ }
 };
 
 static const struct of_device_id qcom_spmi_regulator_match[] = {
-	{ .compatible = "qcom,pm8005-regulators", .data = &pm8005_regulators },
-	{ .compatible = "qcom,pm8841-regulators", .data = &pm8841_regulators },
-	{ .compatible = "qcom,pm8916-regulators", .data = &pm8916_regulators },
-	{ .compatible = "qcom,pm8941-regulators", .data = &pm8941_regulators },
-	{ .compatible = "qcom,pm8994-regulators", .data = &pm8994_regulators },
-	{ .compatible = "qcom,pmi8994-regulators", .data = &pmi8994_regulators },
-	{ .compatible = "qcom,pms405-regulators", .data = &pms405_regulators },
+	{
+		.compatible = "qcom,pm8841-regulators",
+		.data = &pm8841_regulators
+	},
+	{
+		.compatible = "qcom,pm8916-regulators",
+		.data = &pm8916_regulators
+	},
+	{
+		.compatible = "qcom,pm8941-regulators",
+		.data = &pm8941_regulators
+	},
+	{
+		.compatible = "qcom,pmd9655-regulators",
+		.data = &pmd9655_regulators
+	},
 	{ }
 };
 MODULE_DEVICE_TABLE(of, qcom_spmi_regulator_match);
@@ -1955,7 +1693,6 @@ MODULE_DEVICE_TABLE(of, qcom_spmi_regula
 static int qcom_spmi_regulator_probe(struct platform_device *pdev)
 {
 	const struct spmi_regulator_data *reg;
-	const struct spmi_voltage_range *range;
 	const struct of_device_id *match;
 	struct regulator_config config = { };
 	struct regulator_dev *rdev;
@@ -1963,10 +1700,7 @@ static int qcom_spmi_regulator_probe(str
 	struct regmap *regmap;
 	const char *name;
 	struct device *dev = &pdev->dev;
-	struct device_node *node = pdev->dev.of_node;
-	struct device_node *syscon, *reg_node;
-	struct property *reg_prop;
-	int ret, lenp;
+	int ret;
 	struct list_head *vreg_list;
 
 	vreg_list = devm_kzalloc(dev, sizeof(*vreg_list), GFP_KERNEL);
@@ -1983,25 +1717,7 @@ static int qcom_spmi_regulator_probe(str
 	if (!match)
 		return -ENODEV;
 
-	if (of_find_property(node, "qcom,saw-reg", &lenp)) {
-		syscon = of_parse_phandle(node, "qcom,saw-reg", 0);
-		saw_regmap = syscon_node_to_regmap(syscon);
-		of_node_put(syscon);
-		if (IS_ERR(saw_regmap))
-			dev_err(dev, "ERROR reading SAW regmap\n");
-	}
-
 	for (reg = match->data; reg->name; reg++) {
-
-		if (saw_regmap) {
-			reg_node = of_get_child_by_name(node, reg->name);
-			reg_prop = of_find_property(reg_node, "qcom,saw-slave",
-						    &lenp);
-			of_node_put(reg_node);
-			if (reg_prop)
-				continue;
-		}
-
 		vreg = devm_kzalloc(dev, sizeof(*vreg), GFP_KERNEL);
 		if (!vreg)
 			return -ENOMEM;
@@ -2009,6 +1725,7 @@ static int qcom_spmi_regulator_probe(str
 		vreg->dev = dev;
 		vreg->base = reg->base;
 		vreg->regmap = regmap;
+
 		if (reg->ocp) {
 			vreg->ocp_irq = platform_get_irq_byname(pdev, reg->ocp);
 			if (vreg->ocp_irq < 0) {
@@ -2016,12 +1733,10 @@ static int qcom_spmi_regulator_probe(str
 				goto err;
 			}
 		}
+
 		vreg->desc.id = -1;
 		vreg->desc.owner = THIS_MODULE;
 		vreg->desc.type = REGULATOR_VOLTAGE;
-		vreg->desc.enable_reg = reg->base + SPMI_COMMON_REG_ENABLE;
-		vreg->desc.enable_mask = SPMI_COMMON_ENABLE_MASK;
-		vreg->desc.enable_val = SPMI_COMMON_ENABLE;
 		vreg->desc.name = name = reg->name;
 		vreg->desc.supply_name = reg->supply;
 		vreg->desc.of_match = reg->name;
@@ -2032,28 +1747,8 @@ static int qcom_spmi_regulator_probe(str
 		if (ret)
 			continue;
 
-		if (saw_regmap) {
-			reg_node = of_get_child_by_name(node, reg->name);
-			reg_prop = of_find_property(reg_node, "qcom,saw-leader",
-						    &lenp);
-			of_node_put(reg_node);
-			if (reg_prop) {
-				spmi_saw_ops = *(vreg->desc.ops);
-				spmi_saw_ops.set_voltage_sel =
-					spmi_regulator_saw_set_voltage;
-				vreg->desc.ops = &spmi_saw_ops;
-			}
-		}
-
-		if (vreg->set_points && vreg->set_points->count == 1) {
-			/* since there is only one range */
-			range = vreg->set_points->range;
-			vreg->desc.uV_step = range->step_uV;
-		}
-
 		config.dev = dev;
 		config.driver_data = vreg;
-		config.regmap = regmap;
 		rdev = devm_regulator_register(dev, &vreg->desc, &config);
 		if (IS_ERR(rdev)) {
 			dev_err(dev, "failed to register %s\n", name);
Index: linux-5.4.52/include/dt-bindings/iio/qcom,spmi-vadc.h
===================================================================
--- linux-5.4.52.orig/include/dt-bindings/iio/qcom,spmi-vadc.h
+++ linux-5.4.52/include/dt-bindings/iio/qcom,spmi-vadc.h
@@ -221,4 +221,24 @@
 
 #define ADC5_MAX_CHANNEL			0xc0
 
+/*
+ * Channels for PMP8074
+*/
+#define VADC_PMP8074_GND_REF			0x00
+#define VADC_PMP8074_REF_1250MV			0x01
+#define VADC_PMP8074_VDD_VADC			0x02
+#define VADC_PMP8074_RESERVED1			0x03
+#define VADC_PMP8074_RESERVED2			0x04
+#define VADC_PMP8074_RESERVED3			0x05
+#define VADC_PMP8074_DIE_TEMP			0x06
+#define VADC_PMP8074_CHG_TEMP			0x07
+#define VADC_PMP8074_USBIN			0x08
+#define VADC_PMP8074_IREG_FB			0x09
+#define VADC_PMP8074_BAT_THERM			0x0a
+#define VADC_PMP8074_BAT_ID			0x0b
+#define VADC_PMP8074_XOTHERM			0x0c
+#define VADC_PMP8074_AMUX_THM1			0x0d
+#define VADC_PMP8074_AMUX_THM2			0x0e
+#define VADC_PMP8074_AMUX_THM3			0x0f
+
 #endif /* _DT_BINDINGS_QCOM_SPMI_VADC_H */
